  /// \file TestRawDataModule.cc
/*
 *
 * TestRawDataModule.cc source template automatically generated by a class generator
 * Creation date : mar. aoï¿½t 4 2015
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm sdhcal headers
#include "dqmsdhcal/modules/TestRawDataModule.h"
#include "dqmsdhcal/streamout/Streamout.h"

// -- dqm4hep headers
#include "dqm4hep/module/DQMModuleApi.h"
#include "dqm4hep/core/DQMMonitorElement.h"
#include "dqm4hep/core/DQMXmlHelper.h"

// -- lcio headers
#include "EVENT/LCEvent.h"
#include "EVENT/LCCollection.h"
#include "EVENT/RawCalorimeterHit.h"
#include "UTIL/CellIDDecoder.h"

using namespace dqm4hep;

namespace dqm_sdhcal
{

TestRawDataModule aTestRawDataModule;

TestRawDataModule::TestRawDataModule() :
		DQMModule("TestRawDataModule"),
		m_shouldProcessStreamout(true),
		m_shouldProcessTrivent(true),
		m_streamoutInputCollectionName("RU_XDAQ"),
		m_streamoutOutputCollectionName("DHCALRawHits"),
		m_triventInputCollectionName("DHCALRawHits"),
		m_triventOutputCollectionName("SDHCAL_HIT")
{
	setVersion(1, 0, 0);
	setDetectorName("No detector (raw data test)");
}

//-------------------------------------------------------------------------------------------------

TestRawDataModule::~TestRawDataModule() 
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::initModule()
{
	m_pStreamout = new Streamout();

	m_pStreamout->setInputCollectionName(m_streamoutInputCollectionName);
	m_pStreamout->setOutputCollectionName(m_streamoutOutputCollectionName);

	// TODO declare Trivent here and configure it
	// ...

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::mkdir(this, "/RawData"));
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::mkdir(this, "/RawCalorimeterHit"));

	// raw data elements
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::cd(this, "/RawData"));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::bookIntHistogram1D(this,
			m_pRawNumberOfElement, "RawNElements", "Number of raw data buffers (LCGOs)", 201, 0., 199.));

	// reconstructed raw calorimeter hits
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::cd(this, "/RawCalorimeterHit"));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::bookIntHistogram1D(this,
			m_pNRawCalorimeterHits, "NRawCalorimeterHits", "Number of raw calorimeter hits", 2000, 0, 1999));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::bookIntHistogram1D(this,
			m_pAmplitudeDistribution, "Amplitude", "Raw calorimeter hit amplitudes", 10, 0, 9));

	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::bookIntHistogram1D(this,
			m_pTimeDistribution, "Time", "Raw calorimeter hit time", 10000, 0, 10000-1));

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::readSettings(const TiXmlHandle &xmlHandle)
{
	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readValue(xmlHandle,
			"ShouldProcessStreamout", m_shouldProcessStreamout));

	RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readValue(xmlHandle,
			"ShouldProcessTrivent", m_shouldProcessTrivent));

	if(m_shouldProcessStreamout)
	{
		RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readValue(xmlHandle,
				"StreamoutInputCollectionName", m_streamoutInputCollectionName));

		RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readValue(xmlHandle,
				"StreamoutOutputCollectionName", m_streamoutOutputCollectionName));
	}

	if(m_shouldProcessTrivent)
	{
		RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readValue(xmlHandle,
				"TriventInputCollectionName", m_triventInputCollectionName));

		RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readValue(xmlHandle,
				"TriventOutputCollectionName", m_triventOutputCollectionName));
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::processEvent(DQMEvent *pEvent)
{
	std::cout << "dqm event addr " << pEvent << std::endl;
	EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

	if(NULL == pLCEvent)
		return STATUS_CODE_FAILURE;

	std::cout << "lc event addr " << pLCEvent << std::endl;

	try
	{
		std::cout << "Collections in event (BEFORE Streamout) : " << std::endl;

		for(int i=0 ; i<pLCEvent->getCollectionNames()->size() ; i++ )
			std::cout << "  ** " << pLCEvent->getCollectionNames()->at(i) << std::endl;

		std::cout << "m_shouldProcessStreamout : " << m_shouldProcessStreamout << std::endl;
		if(m_shouldProcessStreamout)
		{
			std::cout << "Processing streamout ..." << std::endl;
			THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pStreamout->processEvent(pLCEvent));
		}

		std::cout << "Collections in event (AFTER Streamout) : " << std::endl;
//
		for(int i=0 ; i<pLCEvent->getCollectionNames()->size() ; i++ )
			std::cout << "  ** " << pLCEvent->getCollectionNames()->at(i) << std::endl;

		// TODO process Trivent
	//	if(m_shouldProcessTrivent)
	//	{
	//		// ...
	//	}

		EVENT::LCCollection *pRawDataCollection = pLCEvent->getCollection(m_streamoutInputCollectionName);
		unsigned int nRawElements = pRawDataCollection->getNumberOfElements();
		m_pRawNumberOfElement->get<TH1I>()->Fill(nRawElements);

		EVENT::LCCollection *pRawHitCollection = pLCEvent->getCollection(m_streamoutOutputCollectionName);
		unsigned int nRawHits = pRawHitCollection->getNumberOfElements();
		m_pNRawCalorimeterHits->get<TH1I>()->Fill(nRawHits);

		// analyze raw hits
		for(unsigned int e=0 ; e<pRawHitCollection->getNumberOfElements() ; e++)
		{
			EVENT::RawCalorimeterHit *pRawCalorimeterHit = dynamic_cast<EVENT::RawCalorimeterHit *>(pRawHitCollection->getElementAt(e));

			if(NULL == pRawCalorimeterHit)
				continue;

			int amplitude = pRawCalorimeterHit->getAmplitude();
			m_pAmplitudeDistribution->get<TH1I>()->Fill(amplitude);

			int time = pRawCalorimeterHit->getTimeStamp();
			m_pTimeDistribution->get<TH1I>()->Fill(time);
		}
	}
	catch(StatusCodeException &exception)
	{
		streamlog_out(ERROR) << "Caught StatusCodeException : " << exception.toString() << std::endl;
		return exception.getStatusCode();
	}
	catch(EVENT::DataNotAvailableException &exception)
	{
		streamlog_out(ERROR) << "Caught EVENT::DataNotAvailableException : " << exception.what() << std::endl;
		streamlog_out(ERROR) << "Skipping event" << std::endl;

		return STATUS_CODE_SUCCESS;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::startOfCycle()
{
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::endOfCycle()
{
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::startOfRun(DQMRun *pRun)
{
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::endOfRun(DQMRun *pRun)
{
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::resetModule()
{
	return DQMModuleApi::resetMonitorElements(this, END_OF_CYCLE_RESET_POLICY);
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode TestRawDataModule::endModule()
{
	return STATUS_CODE_SUCCESS;
}

} 

