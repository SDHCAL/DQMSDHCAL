  /// \file DQMRawDataConverter.cc
/*
 *
 * DQMRawDataConverter.cc source template automatically generated by a class generator
 * Creation date : dim. aoï¿½t 30 2015
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqmsdhcal/services/DQMRawDataConverterApplication.h"

#include "dis.hxx"

#include "dqm4hep/core/DQMPluginManager.h"
#include "dqm4hep/lcio/DQMLCEvent.h"
#include "dqm4hep/lcio/DQMLCEventStreamer.h"

#include "EVENT/LCEvent.h"
#include "UTIL/LCTOOLS.h"

#include <fstream>
#include <stdexcept>

using namespace dqm4hep;

namespace dqm_sdhcal
{

std::string converterTypeToString(ConverterType converterType)
{
	switch (converterType)
	{
		CONVERTER_TYPE_TABLE(GET_NAME_SWITCH)
		default : throw dqm4hep::StatusCodeException(STATUS_CODE_INVALID_PARAMETER);
	}
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

DQMRawDataConverterApplication::DQMRawDataConverterApplication() :
		m_stopFlag(false),
		m_returnStatusCode(STATUS_CODE_SUCCESS),
		m_type("RawDataConverter"),
		m_name("UNKNOWN")
{
	// data client and sender
	m_pDataClient = new DQMDataClient();
	m_pDataSender = new DQMDataSender();

	DQMLCEventStreamer *pInputLCEventStreamer = NULL;
	DQMLCEventStreamer *pOutputLCEventStreamer = NULL;

	THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMPluginManager::instance()->getCastedPluginClone("LCIOStreamer", pInputLCEventStreamer));
	pOutputLCEventStreamer = dynamic_cast<DQMLCEventStreamer*>(pInputLCEventStreamer->clone());

	m_pDataClient->setEventStreamer(pInputLCEventStreamer);
	m_pDataSender->setEventStreamer(pOutputLCEventStreamer);

	// streamout and trivent
	m_pStreamout = new Streamout();
	m_pTrivent = new Trivent();
}

//-------------------------------------------------------------------------------------------------

DQMRawDataConverterApplication::~DQMRawDataConverterApplication()
{
	delete m_pDataClient;
	delete m_pDataSender;

	delete m_pStreamout;
	delete m_pTrivent;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRawDataConverterApplication::run()
{
	RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pDataClient->connectToService());
	m_pDataClient->startReceive();

	DimServer::start( ("DQMSDHCAL/" + getType() + "/" + getName()).c_str() );

	bool shouldUseStreamout = (m_converterType != RAW_CALORIMETER_HIT_TO_CALORIMETER_HIT);
	bool shouldUseTrivent =   (m_converterType != RAW_DATA_TO_RAW_CALORIMETER_HIT);

	while(!m_stopFlag)
	{
		DQMEvent *pEvent = m_pDataClient->takeEvent();

		if(!pEvent)
		{
			usleep(100);
			continue;
		}

		EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

		if(!pLCEvent)
		{
			delete pEvent;

			usleep(100);
			continue;
		}

		streamlog_out(DEBUG) << "Event received, ready to process ..." << std::endl;
		StatusCode statusCode = STATUS_CODE_SUCCESS;

		if(shouldUseStreamout)
		  {
		    streamlog_out(DEBUG) << "Processing streamout ..." << std::endl;
			statusCode = m_pStreamout->processEvent(pLCEvent);
		  }

		if(statusCode != STATUS_CODE_SUCCESS)
		  continue;

		if(shouldUseTrivent)
		  {
		    streamlog_out(DEBUG) << "Processing trivent ..." << std::endl;
			statusCode = m_pTrivent->processEvent(pLCEvent);
		  }

		if(statusCode != STATUS_CODE_SUCCESS)
		  continue;
		
		// output is Trivent
		if(shouldUseTrivent)
		{
			const std::vector<EVENT::LCEvent*> &reconstructedEventList(m_pTrivent->getReconstructedEvents());

			streamlog_out(DEBUG) << "Number of reconstructed events (Trivent) : " << reconstructedEventList.size() << std::endl;

			for(std::vector<EVENT::LCEvent*>::const_iterator iter = reconstructedEventList.begin(), endIter = reconstructedEventList.end() ;
					endIter != iter ; ++iter)
			{
				EVENT::LCEvent *pLCEvent = *iter;

				if(NULL == pLCEvent)
					continue;

				DQMEvent *pDQMLCEvent = new DQMLCEvent();
				pDQMLCEvent->setEvent<EVENT::LCEvent>(pLCEvent, false);

				streamlog_out(DEBUG) << "Sending post trivent event" << std::endl;
				StatusCode statusCode = m_pDataSender->sendEvent(pDQMLCEvent);

				if(statusCode != STATUS_CODE_SUCCESS)
				{
					delete pDQMLCEvent;
					throw StatusCodeException(statusCode);
				}

				usleep(m_timeSleepPublication);
			}
		}
		// output is streamout
		else
		{
		  //		  pLCEvent->dropCollection();
			DQMEvent *pDQMLCEvent = new DQMLCEvent();
			pDQMLCEvent->setEvent<EVENT::LCEvent>(pLCEvent, false);
			UTIL::LCTOOLS::dumpEvent(pLCEvent);

			streamlog_out(DEBUG) << "Sending post streamout event" << std::endl;
			StatusCode statusCode = m_pDataSender->sendEvent(pDQMLCEvent);

			if(statusCode != STATUS_CODE_SUCCESS)
			{
				delete pDQMLCEvent;
				throw StatusCodeException(statusCode);
			}

			usleep(m_timeSleepPublication);
		}

		delete pLCEvent;
	}

	return m_returnStatusCode;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRawDataConverterApplication::exit(int returnCode)
{
	if(m_pDataClient)
		m_pDataClient->stopReceive();

	m_stopFlag = true;

	if(returnCode > 0 && returnCode < NUMBER_OF_STATUS_CODES)
		m_returnStatusCode = static_cast<StatusCode>(returnCode);
	else
		m_returnStatusCode = STATUS_CODE_FAILURE;

	return m_returnStatusCode;
}

//-------------------------------------------------------------------------------------------------

StatusCode DQMRawDataConverterApplication::readSettings(const std::string &settingsFileName)
{
	try
	{
		// parse json file
		Json::Reader reader;
		std::ifstream settingsFile (settingsFileName.c_str(), std::ifstream::in);

		Json::Value rootValue;
		bool parsedSuccess = reader.parse(settingsFile, rootValue, false);

		if(!parsedSuccess)
		{
			streamlog_out(ERROR) << "Couldn't parse json file :" << std::endl;
			streamlog_out(ERROR) << reader.getFormatedErrorMessages() << std::endl;

			return STATUS_CODE_FAILURE;
		}

		m_timeSleepPublication = rootValue.get("TimeSleepPublication", 1000).asUInt();

		std::string inputCollectorName = rootValue["InputCollectorName"].asString();
		std::string outputCollectorName = rootValue["OutputCollectorName"].asString();

		m_pDataClient->setCollectorName(inputCollectorName);
		m_pDataSender->setCollectorName(outputCollectorName);

		unsigned int converterType = rootValue["ConverterType"].asUInt();

		if(converterType >= NUMBER_OF_CONVERTER_TYPES)
			return STATUS_CODE_INVALID_PARAMETER;

		m_converterType = static_cast<ConverterType>(converterType);

		m_name = converterTypeToString(m_converterType);

		bool shouldUseStreamout = (m_converterType != RAW_CALORIMETER_HIT_TO_CALORIMETER_HIT);
		bool shouldUseTrivent =   (m_converterType != RAW_DATA_TO_RAW_CALORIMETER_HIT);

		if(shouldUseStreamout)
		{
		  const Json::Value &streamoutValue = rootValue["Streamout"];

		  std::string inputCollectionName = streamoutValue["InputCollectionName"].asString();
		  std::string outputCollectionName = streamoutValue["OutputCollectionName"].asString();
		  
		  streamlog_out(DEBUG) << "Setting input collection : " << inputCollectionName << std::endl;
		  streamlog_out(DEBUG) << "Setting output collection : " << outputCollectionName << std::endl;
		  
		  m_pStreamout->setInputCollectionName(inputCollectionName);
		  m_pStreamout->setOutputCollectionName(outputCollectionName);
		}

		if(shouldUseTrivent)
		{
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pTrivent->readSettings(rootValue["Trivent"]));
			RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pTrivent->init());
//			m_pTrivent->setOutputCollectionName(outputCollectionName);
//
//			if(!shouldUseStreamout)
//				m_pTrivent->setInputCollectionName(inputCollectionName);
//			else
//				m_pTrivent->setInputCollectionName("DHCALRawHits");

//			std::string geometryFile = rootValue["GeometryFile"].asString();
//			m_pTrivent->setGeometryXMLFile(geometryFile);
		}
	}
	catch(const std::runtime_error &exception)
	{
		return STATUS_CODE_NOT_FOUND;
	}

	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMRawDataConverterApplication::getType() const
{
	return m_type;
}

//-------------------------------------------------------------------------------------------------

const std::string &DQMRawDataConverterApplication::getName() const
{
	return m_name;
}

} 

