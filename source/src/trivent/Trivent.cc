/// \file Streamout.cc
/*
*
* Streamout.cc source template automatically generated by a class generator
* Creation date : lun. aoï¿½t 3 2015
*
* This file is part of DQMSDHCAL libraries.
*
* DQMSDHCAL is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* DQMSDHCAL is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Yacine Haddad, Arnaud Steen, Remi Ete, Antoine Pingault
* @copyright CNRS , IPNL, UGent
*/

// -- dqm sdhcal headers
#include <dqmsdhcal/trivent/Trivent.h>

// -- lcio headers
#include <EVENT/LCIO.h>
#include <EVENT/LCCollection.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCEventImpl.h>
#include <EVENT/LCFloatVec.h>
#include <EVENT/LCParameters.h>
#include <UTIL/CellIDEncoder.h>

// -- std headers
#include <limits.h>
#include <cmath>
#include <stdexcept>
#include <sstream>
#include <fstream>
#include <algorithm>

namespace dqm_sdhcal
{

Trivent::Trivent():
    m_inputCollectionName("DHCALRawHits"),
    m_outputCollectionName("SDHCAL_HIT"),
    m_layerCut(10),
    m_noiseCut(10),
    m_timeWindow(2),
    m_geomXMLFile("setup_geometry.xml"),
    m_layerGap(.9),
    m_elecNoiseCut(100000),
    m_time2PreviousEventCut(0),
    m_gainCorrectionMode(false),
    m_cerenkovWindow(20),
    m_cerenkovLength(1),
    m_cerenkovDifId(3),
    m_rejectedEvt(0),
    m_selectedEvt(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

Trivent::~Trivent()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode readGeometry(const std::string &fileName)
{
	dqm4hep::TiXmlDocument document(filename);

	if(!document.LoadFile())
		return dqm4hep::STATUS_CODE_FAILURE;

	dqm4hep::TiXmlHandle documentHandle(&document);
	dqm4hep::TiXmlElement* pRootElement = documentHandle.FirstChildElement().Element();

	if(NULL == pRootElement)
		return dqm4hep::STATUS_CODE_FAILURE;

	// root element handler
	dqm4hep::TiXmlHandle rootHandle(pRootElement);

	m_parameters.clear();

	bool difGeomFound = false;
	bool chamberGeomFound = false;

	for(TiXmlElement *pParameterElement = rootHandle.FirstChild("parameter").Element(); NULL != pParameterElement;
			pParameterElement = pParameterElement->NextSiblingElement("parameter"))
	{
		// parameter name
		const char *pParameterNameStr = pParameterElement->Attribute("name");

		if(NULL == pParameterNameStr)
			return dqm4hep::STATUS_CODE_NOT_FOUND;

		std::string parameterName = pParameterElementStr;

		if(parameterName == "DifGeom")
		{
			RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->readDifGeometry(pParameterElement));
			difGeomFound = true;
		}
		else if(parameterName = "ChamberGeom")
		{
			RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->readChamberGeometry(pParameterElement));
			chamberGeomFound = true;
		}
		else
		{
			std::cout << "Unknown parameter element, name : " << parameterName << std::endl;
			continue;
		}
	}

	if(!difGeomFound || !chamberGeomFound)
		return dqm4hep::STATUS_CODE_FAILURE;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode Trivent::readDifGeometry(TiXmlElement *pElement)
{
	if(NULL == pElement)
		return dqm4hep::STATUS_CODE_FAILURE;

	// get the element contents
	const char *pValueStr = pElement->GetText();

	if(NULL == pValueStr)
		return STATUS_CODE_NOT_FOUND;

	// clear dif mapping
	m_difMapping.clear();

	std::string value = pValueStr;
	std::vector<std::string> lines;

	// split the contents for each lines
	dqm4hep::DQM4HEP::tokenize(value, lines, "\n");

	for(unsigned int i=0 ; i<lines.size() ; i++)
	{
		std::string line = lines.at(i);
		std::vector<std::string> tokens;

		LayerID layerId;
		int difId;

		// split the line with commas
		dqm4hep::DQM4HEP::tokenize(line, tokens, ",");

		// fill LayerID object
		dqm4hep::stringToType(tokens.at(0), difId);
		dqm4hep::stringToType(tokens.at(1), layerId.K);
		dqm4hep::stringToType(tokens.at(2), layerId.DifX);
		dqm4hep::stringToType(tokens.at(3), layerId.DifY);
		dqm4hep::stringToType(tokens.at(4), layerId.IncX);
		dqm4hep::stringToType(tokens.at(5), layerId.IncY);

		// add the dif entry
		m_difMapping[difId] = layerId;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode Trivent::readChamberGeometry(TiXmlElement *pElement)
{
	if(NULL == pElement)
		return dqm4hep::STATUS_CODE_FAILURE;

	// get the element contents
	const char *pValueStr = pElement->GetText();

	if(NULL == pValueStr)
		return STATUS_CODE_NOT_FOUND;

	// clear the chamber positions
	m_chamberPositions.clear();

	std::string value = pValueStr;
	std::vector<std::string> lines;

	// split the contents by lines
	dqm4hep::DQM4HEP::tokenize(value, lines, "\n");

	for(unsigned int i=0; i<lines.size(); i++)
	{
		std::string line = lines.at(i);
		std::vector<std::string> tokens;

		double position;
		int difId;

		// split the lines with commas
		dqm4hep::DQM4HEP::tokenize(lines, tokens, ",");

		dqm4hep::stringToType(tokens.at(0), difId);
		dqm4hep::stringToType(tokens.at(0), position);

		// add a chamber entry
		m_chamberPositions[difId] = position;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

// ============ decode the cell ids =============
// Dif 1 => cellID0= 00983297 => DifID=1 / AsicID=1 / ChanID=15

// Applique le masque 1111 1111
unsigned int Trivent::getCellDifId(int cellId)
{
    return cellId & 0xFF;
}
//-------------------------------------------------------------------------------------------------

//  Applique le masque 1111 1111 0000 0000 puis tronque les 8 derniers bits
unsigned int Trivent::getCellAsicId(int cellId)
{
    return (cellId & 0xFF00)>>8;
}

//-------------------------------------------------------------------------------------------------

//  Applique le masque 1111 0000 0000 0000 0000 puis tronque les 16 derniers bits
unsigned int Trivent::getCellChanId(int cellId)
{
    return (cellId & 0x3F0000)>>16;
}

// ============ ============ ============ ============ ============ ============ ============ ============
// ============ ============ ============ ============ ============ ============ ============ ============
// Exemple sur Dif 1:
// cellId0 = 00983297 -> Binaire =  1111 0000 0001 0000 0001
// binaire & 0xFF = 0000 0001 => 2^0=1
// binaire & 0xFF00 = 0000 0001 0000 0000 >>8 = 0000 0001 => 2^0=1
// binaire & 0x3F0000 =  1111 0000 0000 0000 0000 >>16 = 1111 => (2^3)+(2^2)+(2^1)+(2^0)=15
// ============ ============ ============ ============ ============ ============ ============ ============
// ============ ============ ============ ============ ============ ============ ============ ============

//-------------------------------------------------------------------------------------------------

std::vector<dqm4hep::dqm_uint> Trivent::getPadIndex(uint difId, uint asicId, uint chanId)
{
	std::vector<dqm4hep::dqm_uint> index(3, 0);

    int difY = static_cast<int>(m_mapping.find(difId)->second.difY);
    int difZ = static_cast<int>(m_mapping.find(difId)->second.K);

    index[0] = ( 1 + MapILargeHR2[chanId] + AsicShiftI[asicId] );
    index[1] = ( 32 - (MapJLargeHR2[chanId]+AsicShiftJ[asicId]) ) + difY;
    index[2] = abs(difZ);

    return index;
}

//-------------------------------------------------------------------------------------------------

int Trivent::getMaxTime()
{
    int maxTime = 0;

	for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit = m_triggerRawHit.begin() ;
			rawHit != m_triggerRawHit.end() ; rawHit++)
	{
		int time = static_cast<int>((*rawHit)->getTimeStamp());

		if(time >= 0)
			m_maxTime = std::max(m_maxTime, time);
	}

	return maxTime;
}

//-------------------------------------------------------------------------------------------------

std::vector<int> Trivent::getTimeSpectrum()
{
	int maxTime = this->getMaxTime();
    std::vector<int> timeSpectrum(maxTime + 1);

	for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit = m_triggerRawHit.begin() ;
			rawHit != m_triggerRawHit.end() ; rawHit++)
	{
		int time = int((*rawHit)->getTimeStamp());

		if(time >= 0)
			timeSpectrum.at(time)++;
	}

    return timeSpectrum;
}

//-------------------------------------------------------------------------------------------------

bool Trivent::peakOrNot(std::vector<int> timeSpectrum , int iTime, int threshold)
{
	return (timeSpectrum.at(iTime) >= threshold
		  && timeSpectrum.at(iTime) > timeSpectrum.at(iTime+1));
}

//-------------------------------------------------------------------------------------------------

int Trivent::ijkToKey(int i, int j, int k)
{
	return 100*100*k+100*j+i;
}

//-------------------------------------------------------------------------------------------------

int Trivent::findAsicKey(int i, int j, int k)
{
    if(i>96 || i<0 || j>96 || j<0)
    	return -1;

    return k*1000+(((j-1)/8)*12 + (i-1)/8);
}

//-------------------------------------------------------------------------------------------------

void Trivent::eventBuilder(LCCollection* colEvent,int timePeak, int previousTimePeak){
    _zCut.clear();

    colEvent->setFlag(colEvent->getFlag()|( 1 << LCIO::RCHBIT_LONG));
    colEvent->setFlag(colEvent->getFlag()|( 1 << LCIO::RCHBIT_TIME));
    CellIDEncoder<CalorimeterHitImpl> cd( "M:3,S-1:3,I:9,J:9,K-1:6" ,colEvent) ;
    std::map<int,int> asicMap;

    try{
        std::vector<int> hitKeys;
        int previousTime = 0;
        int cerenkovTime = 0;
        for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit=m_triggerRawHit.begin();rawHit!= m_triggerRawHit.end();rawHit++){
            float pos[3];
            int time = (*rawHit)->getTimeStamp();

            int Dif_id  =  getCellDifId ((*rawHit)->getCellID0());

            // CTag has an offset of ~5 in December 2014, 7-17 in May/April 2015
            // Need to modify the timeWin in the following loop to analyse it
            if (Dif_id == m_cerenkovDifId) m_timeWindow = m_cerenkovWindow;
            else m_timeWindow = 2;

            if(fabs(time-timePeak) <= m_timeWindow &&
                    (time > previousTimePeak + m_timeWindow ))
            {
                int Asic_id =  getCellAsicId((*rawHit)->getCellID0());
                int Chan_id =  getCellChanId((*rawHit)->getCellID0());

                uint I = getPadIndex(Dif_id, Asic_id, Chan_id)[0];
                uint J = getPadIndex(Dif_id, Asic_id, Chan_id)[1];
                uint K = getPadIndex(Dif_id, Asic_id, Chan_id)[2];

                // Find and remove square events
                int asicKey = findAsicKey(I,J,K);
                if(asicMap[asicKey]) asicMap[asicKey]++;
                else asicMap[asicKey]=1;
                if( asicMap[asicKey]==64 ){
                    _zCut.clear();
                    hitKeys.clear();
                    asicMap.clear();
                    return;
                }

                int aHitKey=IJKToKey(I,J,K);
                pos[0] = I*10.*1.04125;
                pos[1] = J*10.*1.04125;
                pos[2] = K*26.131;

                // If No more CTag Reset it to 0
                if ( cerenkovTime - previousTime > 1)
                {
                    streamlog_out ( DEBUG0 ) << red << "cerenkovTime - previousTime: " << cerenkovTime - previousTime << normal << std::endl;
                    m_cerenkovFlag[0] = m_cerenkovFlag[1] = m_cerenkovFlag[2] = 0;
                    m_cerenkovCount[0] = m_cerenkovCount[1] = m_cerenkovCount[2] = 0;
                }

                // Treat CTag
                if (Dif_id == m_cerenkovDifId)
                {
                    cerenkovTime = time;
                    streamlog_out ( MESSAGE ) << green << "Event #: " << m_evtNbr << "\tTrigger #: " << m_trigCount <<  \
                                                 "\tDelta t:" << time - timePeak << "\tAt Time:" << time << "\tMaxTime: " << m_maxTime << "\t MaxTime - CeremkovTime: " << m_maxTime - time << normal << std::endl;

                    unsigned short cerenkovAmplitude = (*rawHit)->getAmplitude();
                    streamlog_out( MESSAGE ) << blue << "CTag amplitude: " << cerenkovAmplitude << normal << std::endl;

                    // In december 2014 only one Cerenkov was used and its signal spanned on 4-5times slot
                    // Need to be treated separately to not count the CTag multiple time
                    // Besides in Decmeber cerenkovAmplitude for the CTag is equal to 5
                    if (cerenkovAmplitude == 5)
                    {
                        m_cerenkovCount[2]++;
                        m_cerenkovCountTotal[2]++;
                        if (m_cerenkovFlag[2] == 0) m_cerenkovFlag[2] = 1;
                    }
                    else if (cerenkovAmplitude<3) // In may/April 2015 2 Cerenkov. cerenkovAmplitude = 1 = CTag1
                        //                                                             = 2 = CTag2
                        //                                                             = 3 = CTag1 + CTag2
                    {
                        m_cerenkovCount[cerenkovAmplitude-1]++;
                        m_cerenkovCountTotal[cerenkovAmplitude-1]++;
                        if (m_cerenkovFlag[cerenkovAmplitude-1] == 0) m_cerenkovFlag[cerenkovAmplitude-1] = 1;
                    }
                }

                if(K<=0||K>64)
                {
                    streamlog_out( MESSAGE ) << " Dif_id  == " << Dif_id
                                             << " Asic_id == " << Asic_id
                                             << " Chan_id == " << Chan_id
                                             << " I == " << I
                                             << " J == " << J
                                             << " K == " << K
                                             << std::endl;
                    continue;
                }

                x.push_back( pos[0] );
                y.push_back( pos[1] );
                z.push_back( pos[2] );
                fThr.push_back( int((*rawHit)->getAmplitude()) );
                fDifId.push_back( Dif_id );
                fTime.push_back( time );
                fPrevTime.push_back( prevTime );
                fTimePeak.push_back( timePeak );
                fPrevTimePeak.push_back( previousTimePeak  );
                fDeltaTimePeak.push_back( time - timePeak );
                fNevt.push_back( m_evtNbr );

                streamlog_out ( DEBUG0 ) << green << "Evt: " << m_evtNbr << "\t Previous: " << m_previousEvtNbr << normal << std::endl;
                if ( m_evtNbr == m_previousEvtNbr ) fEvtReconstructed.push_back( 0 ); // To have only 1 entry per evt reconstructed and not the hit number
                else                         fEvtReconstructed.push_back( m_evtNbr );

                fTriggerNr.push_back( m_trigCount );
                fNhit.push_back( colEvent->getNumberOfElements() );
                fCerenkovTag1.push_back( m_cerenkovFlag[0] );
                fCerenkovTag2.push_back( m_cerenkovFlag[1] );
                fCerenkovTag3.push_back( m_cerenkovFlag[2] );
                fCerenkovCount1.push_back ( m_cerenkovCount[0] );
                fCerenkovCount2.push_back ( m_cerenkovCount[1] );
                fCerenkovCount3.push_back ( m_cerenkovCount[2] );

                if (m_cerenkovCount[2] == 4)                      //True CTag in December span over 5clocks
                    fCerenkovCountDecember.push_back( 1 );
                else
                    fCerenkovCountDecember.push_back( 0 );

                CalorimeterHitImpl* caloHit = new CalorimeterHitImpl();
                caloHit->setTime(float((*rawHit)->getTimeStamp()));

                if(float((*rawHit)->getAmplitude()&3)>2.5) caloHit->setEnergy(float((*rawHit)->getAmplitude()&3));         // 3rd treshold
                else if(float((*rawHit)->getAmplitude()&3)>1.5) caloHit->setEnergy(float((*rawHit)->getAmplitude()&3)-1);  // 2nd treshold -1 to shift color to green
                else caloHit->setEnergy(float((*rawHit)->getAmplitude()&3)+1);                                             // 1st treshold +1 to shift color to blue

                //avoid two hit in the same cell
                if(std::find(hitKeys.begin(),hitKeys.end(),aHitKey)!=hitKeys.end())
                {
                    IMPL::CalorimeterHitImpl* hit =
                            dynamic_cast<IMPL::CalorimeterHitImpl*>(colEvent->getElementAt(std::distance(hitKeys.begin(),std::find(hitKeys.begin(),hitKeys.end(),aHitKey))));
                    float hitTime = hit->getTime();
                    if( fabs(timePeak-hitTime)>fabs(timePeak-time) )
                    {
                        hit->setEnergy(caloHit->getEnergy());
                    }
                    continue;
                }

                // set the cell id
                cd["I"] = I ;
                cd["J"] = J ;
                cd["K-1"] = K-1 ;
                cd["M"] = 0 ;
                cd["S-1"] = 3 ;
                streamlog_out( DEBUG0 ) << " I == " << I
                                        << " J == " << J
                                        << " K == " << K
                                        << std::endl;
                cd.setCellID( caloHit ) ;
                if(std::find(_zCut.begin(), _zCut.end(), K)==_zCut.end())
                    _zCut.push_back(K);
                caloHit->setPosition(pos);
                colEvent->addElement(caloHit);
                hitKeys.push_back(aHitKey);

                streamlog_out ( DEBUG0 ) << red << "Evt: " << m_evtNbr << "\t Previous: " << _previousEvtNbr << normal << std::endl;
                _previousEvtNbr=m_evtNbr;
                streamlog_out ( DEBUG0 ) << yellow << "Evt: " << m_evtNbr << "\t Previous: " << _previousEvtNbr << normal << std::endl;
            } // End if (timeWin)
            prevTime = time;
        }//loop over the hit
        hitKeys.clear();
    }catch(DataNotAvailableException &e){
        streamlog_out(WARNING) << " collection not available" << std::endl;
    }
}

//===============================================
void Trivent::init() {
    m_trigCount = 0;
    _cerenkovFlag[0] = _cerenkovFlag[1] = _cerenkovFlag[2] = 0;
    _cerenkovCount[0] = _cerenkovCount[1] = _cerenkovCount[2] = 0;
    _cerenkovCountTotal[0] = _cerenkovCountTotal[1] = _cerenkovCountTotal[2] = 0;
    //========================
    //readDifGeomFile(_mappingfile.c_str());

    // ========================

    printParameters();
    // new process


    XMLReader(m_geomXMLFile.c_str());
    m_evtNbr=0;// event number
    _previousEvtNbr =0;

}

//==================================================================================
void Trivent::processEvent( LCEvent * evtP ){

    ClearVector();
    if (evtP != NULL)
    {
        try
        {
            _eventNbr=evtP->getEventNumber();
            for(unsigned int i=0; i< _hcalCollections.size(); i++){//!loop over collection
                try
                {
                    LCCollection * col = NULL;
                    col = evtP ->getCollection(_hcalCollections[i].c_str());
                    int numElements = col->getNumberOfElements();// hit number
                    if ( m_trigCount==0 || (m_trigCount % 100) == 0)
                    {
                        streamlog_out( MESSAGE ) << "Selected Event so far: " << _selectedNum << std::endl;
                        streamlog_out( MESSAGE ) << yellow << "Trigger number == " << m_trigCount << normal << std::endl;
                    }
                    m_trigCount++;

                    if(col == NULL )  {
                        streamlog_out( WARNING )<< red << "TRIGGER SKIPED ...Col == NULL"<< normal <<std::endl;
                        break;
                    }

                    if(numElements > m_elecNoiseCut)  {
                        streamlog_out( DEBUG ) << red << "TRIGGER SKIPED ...NoiseCut"<< normal <<std::endl;
                        break;
                    }

                    // set raw hits
                    m_triggerRawHit.clear();
                    m_cerenkovHits.clear();
                    std::vector<int> vTrigger;

                    for (int ihit(0); ihit < col->getNumberOfElements(); ++ihit) // loop over the hits
                    {
                        RawCalorimeterHit *rawHit =
                                dynamic_cast<RawCalorimeterHit*>( col->getElementAt(ihit)) ;
                        if (NULL != rawHit)
                        {
                            unsigned int difid=0;
                            difid = rawHit->getCellID0()&0xFF;

                            //extract abolute bcid information:
                            if(ihit==0)
                            {
                                if (difid==0) continue;

                                std::stringstream pname("");
                                pname <<"DIF"<<difid<<"_Triggers";

                                col->getParameters().getIntVals(pname.str(),vTrigger);
                                if (vTrigger.size()!=0)
                                {
                                    _bcid1=vTrigger[4] ;
                                    _bcid2=vTrigger[3] ;
                                    unsigned long long Shift=16777216ULL;//to shift the value from the 24 first bits
                                    unsigned long long theBCID_=_bcid1*Shift+_bcid2;
                                    streamlog_out( DEBUG1 ) << "trigger time : " << theBCID_ << std::endl;
                                }
                            }

                            //                            // Shift the CTag to be around the Event Time
                            //                            if (difid == _cerenkovDifId) {
                            //                                streamlog_out( DEBUG ) << blue << "Hit: " << ihit << " Ca tape dans l'tcher!" << normal << std::endl;

                            //                                // Copy RawHit into a CerenkovHit
                            //                                IMPL::RawCalorimeterHitImpl *pCerenkRawHit = new IMPL::RawCalorimeterHitImpl;
                            //                                pCerenkRawHit->setAmplitude(rawHit->getAmplitude());
                            //                                pCerenkRawHit->setCellID0(rawHit->getCellID0());
                            //                                pCerenkRawHit->setCellID1(rawHit->getCellID1());
                            //                                pCerenkRawHit->setTimeStamp(rawHit->getTimeStamp() + _cerenkovOffset); // Shift CTag with delay added in the acquisition
                            //                                //                                _cerenkovHits.push_back(pCerenkRawHit);
                            //                                m_triggerRawHit.push_back(pCerenkRawHit);
                            //                                //                                delete pCerenkRawHit; pCerenkRawHit = NULL;

                            //                            }else
                            //                            {
                            //                                streamlog_out( MESSAGE ) << red << "Hit: " << ihit << " Ca tape pas dans l'tcher!" << normal << std::endl;
                            m_triggerRawHit.push_back(rawHit);
                            //                            }
                        }
                    }
                    getMaxTime();
                    std::vector<int> timeSpectrum = getTimeSpectrum();

                    //---------------------------------------------------------------
                    //! Find the candidate event
                    int ibin=0;
                    int bin_c_prev = -2 * m_timeWindow; //  the previous bin center

                    int time_prev = 0;
                    while(ibin < (m_maxTime+1)){
                        if(timeSpectrum[ibin] >= m_noiseCut &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin+1] &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin-1] &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin-2] &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin+2] )
                        {
                            LCEventImpl*  evt = new LCEventImpl() ;     // create the event

                            //---------- set event paramters ------
                            const std::string parname_trigger = "trigger";
                            const std::string parname_energy  = "beamEnergy";
                            const std::string parname_bcid1 = "bcid1";
                            const std::string parname_bcid2 = "bcid2";
                            const std::string parname_cerenkov1 = "cerenkov1";
                            const std::string parname_cerenkov2 = "cerenkov2";
                            const std::string parname_cerenkov3 = "cerenkov3";

                            evt->parameters().setValue(parname_trigger,evtP->getEventNumber());
                            evt->parameters().setValue(parname_energy , m_beamEnergy);
                            evt->parameters().setValue(parname_bcid1 , _bcid1);
                            evt->parameters().setValue(parname_bcid2 , _bcid2);
                            evt->setRunNumber( evtP->getRunNumber()) ;

                            //-------------------------------------
                            LCCollectionVec* outcol = new LCCollectionVec(LCIO::CALORIMETERHIT);

                            m_evtNbr++;
                            _cerenkovCount[0] = _cerenkovCount[1] = _cerenkovCount[2] = 0;


                            Trivent::eventBuilder(outcol,ibin,bin_c_prev);
                            evt->parameters().setValue(parname_cerenkov1, _cerenkovCount[0]); // Value determined in the eventBuilder
                            evt->parameters().setValue(parname_cerenkov2, _cerenkovCount[1]); // Value determined in the eventBuilder
                            evt->parameters().setValue(parname_cerenkov3, _cerenkovCount[2]); // Value determined in the eventBuilder
                            // ->Need to be after the EventBuilder function

                            if( (int)_zCut.size() >m_layerCut &&                                  // the min layer numb cut
                                    abs(int(ibin)-time_prev) > m_time2PreviousEventCut)// time2prev event  cut
                            {

                                streamlog_out( DEBUG ) << "Evt number : " <<  m_evtNbr << std::endl;
                                streamlog_out( DEBUG ) <<green<<" Trivent find event at :==> "<< red << ibin
                                                      <<green<<"\t :Nhit: ==> "<< magenta
                                                     <<outcol->getNumberOfElements() << normal <<std::endl;
                                evt->setEventNumber( m_evtNbr ) ;
                                evt->addCollection(outcol, "SDHCAL_HIT");
                                _lcWriter->writeEvent( evt ) ;
                                evts.push_back(evt);
                                _selectedNum++;

                            }else
                            {
                                _rejectedNum++;
                                delete outcol; outcol = NULL;
                            }
                            time_prev = ibin;
                            delete evt; evt=NULL;
                            bin_c_prev = ibin;
                            ibin = ibin+m_timeWindow;
                        }else{ibin++;}
                    }
                    _tree->Fill();
                }catch (lcio::DataNotAvailableException zero) {}
            }
        }catch (lcio::DataNotAvailableException err) {}
    }


}
//==============================================================
void Trivent::end()
{
    streamlog_out( MESSAGE )<< "Trivent Rejected "<<_rejectedNum <<" Candidate event"<<std::endl;
    streamlog_out( MESSAGE )<< "Trivent Selected "<<_selectedNum <<" Candidate event"<<std::endl;
    streamlog_out( MESSAGE )<< "Trivent end"<<std::endl;
    streamlog_out( MESSAGE )<< "Total Cerenkov1 Tags: " << _cerenkovCountTotal[0] << std::endl;
    streamlog_out( MESSAGE )<< "Total Cerenkov2 Tags: " << _cerenkovCountTotal[1] << std::endl;
    streamlog_out( MESSAGE )<< "Total Cerenkov3 Tags: " << _cerenkovCountTotal[2] << std::endl;


    // cc.StoreHistos("test.root");
    _lcWriter->close();


    if (_tree) {
        TFile *_logroot = _tree->GetCurrentFile();
        _logroot->Write();
        delete _logroot;
    }
}
//==============================================================

void Trivent::setInputCollectionName(const std::string &inputCollectionName)
{
    m_inputCollectionName = inputCollectionName;
}

void Trivent::setOutputCollectionName(const std::string &outputCollectionName)
{
    m_outputCollectionName = outputCollectionName;
}

void Trivent::setOutputNoiseFileName(const std::string &noiseFileName)
{
    m_noiseFileName = noiseFileName;
}

void Trivent::setGeometryXMLFile(const std::string &geomXMLFile)
{
    m_geomXMLFile = geomXMLFile;
}

void Trivent::setLayerCut(const int &layerCut)
{
    m_layerCut = layerCut;
}

void Trivent::setNoiseCut(const int &noiseCut)
{
    m_noiseCut = noiseCut;
}

void Trivent::setTimeWindow(const int &timeWindow)
{
    m_timeWindow = timeWindow;
}

void Trivent::setLayerGap(const double &layerGap)
{
    m_layerGap = layerGap;
}

void Trivent::setElecNoiseCut(const int &elecNoiseCut)
{
    m_elecNoiseCut = elecNoiseCut;
}

void Trivent::setTime2PreviousEventCut(const int &time2PreviousEventCut)
{
    m_time2PreviousEventCut = time2PreviousEventCut;
}

void Trivent::setGainCorrectionMode(const bool gainCorrectionMode)
{
    m_gainCorrectionMode = gainCorrectionMode;
}

void Trivent::setCerenkovWindow(const int cerenkovWindow)
{
    m_cerenkovWindow = cerenkovWindow;
}

void Trivent::setCerenkovLength(const int cerenkovLength)
{
    m_cerenkovLength = cerenkovLength;
}

void Trivent::setCerenkovDifId(const int cerenkovDifId)
{
    m_cerenkovDifId = cerenkovDifId;
}


}
