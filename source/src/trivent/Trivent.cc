/// \file Streamout.cc
/*
*
* Streamout.cc source template automatically generated by a class generator
* Creation date : lun. aoï¿½t 3 2015
*
* This file is part of DQMSDHCAL libraries.
*
* DQMSDHCAL is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* DQMSDHCAL is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Yacine Haddad, Arnaud Steen, Remi Ete, Antoine Pingault
* @copyright CNRS , IPNL, UGent
*/

// -- dqm sdhcal headers
#include <dqmsdhcal/trivent/Trivent.h>

// -- lcio headers
#include <EVENT/LCIO.h>
#include <EVENT/LCCollection.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCEventImpl.h>
#include <EVENT/LCFloatVec.h>
#include <EVENT/LCParameters.h>
#include <UTIL/CellIDEncoder.h>



#include <limits.h>
#include <cmath>
#include <stdexcept>
#include <Rtypes.h>
#include <sstream>


#include "TObject.h"
#include "TRefArray.h"
#include "TRef.h"
#include <fstream>
#include <algorithm>

namespace dqm_sdhcal
{


Trivent::Trivent():
    m_inputCollectionName("DHCALRawHits"),
    m_outputCollectionName("SDHCAL_HIT"),
    m_noiseFileName("noise_run.slcio"),
    m_layerCut(10),
    m_noiseCut(10),
    m_timeWindow(2),
    m_geomXMLFile("setup_geometry.xml"),
    m_layerGap(.9),
    m_elecNoiseCut(100000),
    m_time2PreviousEventCut(0),
    m_gainCorrectionMode(false),
    m_cerenkovWindow(20),
    m_cerenkovLength(1),
    m_cerenkovDifId(3),
    m_rejectedEvt(0),
    m_selectedEvt(0)
{
}

//-------------------------------------------------------------------------------------------------
Trivent::~Trivent()
{
}

//-------------------------------------------------------------------------------------------------
void Trivent::XMLReader(std::string xmlfile)
{
    TiXmlDocument doc(xmlfile.c_str());
    bool load_key = doc.LoadFile();
    if(load_key){
        streamlog_out( MESSAGE ) << green << "File : " << xmlfile.c_str() << normal <<std::endl;
        // tout ici
        TiXmlHandle hDoc(&doc);
        TiXmlElement* pElem;
        TiXmlHandle hRoot(0);
        // name block
        {
            pElem=hDoc.FirstChildElement().Element();
            // should always have a valid root but handle gracefully if it does
            if (!pElem) streamlog_out( WARNING ) << red << "error elem" << normal << std::endl;
            streamlog_out( MESSAGE ) << green << pElem->Value() << normal << std::endl;

            // save this for later
            hRoot=TiXmlHandle(pElem);
        }
        // parameters block
        {
            m_parameters.clear();
            pElem=hRoot.FirstChild("parameter").Element();
            std::string key = pElem->Attribute("name");
            streamlog_out( MESSAGE ) << green << key.c_str() << normal << std::endl;
            streamlog_out( DEBUG1 ) << green
                                    <<"parameter : "
                                   << pElem->Attribute("name")
                                   << normal
                                   << std::endl;

            std::vector<std::string> lines;
            {
                std::string value = pElem->GetText() ;
                std::vector<std::string> lines;
                istringstream iss(value);
                copy(istream_iterator<string>(iss),
                     istream_iterator<string>(),
                     back_inserter<vector<string> >(lines));
                for(unsigned int iline = 0; iline < lines.size(); iline++){
                    std::string line = lines.at(iline);
                    streamlog_out( MESSAGE ) << red << line << normal << std::endl;

                    stringstream ss( line.c_str() );
                    vector<string> result;

                    LayerID mapp;
                    int difId;
                    while( ss.good() )
                    {
                        string substr;
                        getline( ss, substr, ',' );
                        result.push_back( substr );
                    }
                    istringstream ( result.at(0) ) >> difId;
                    istringstream ( result.at(1) ) >> mapp.K;
                    istringstream ( result.at(2) ) >> mapp.DifX;
                    istringstream ( result.at(3) ) >> mapp.DifY;
                    istringstream ( result.at(4) ) >> mapp.IncX;
                    istringstream ( result.at(5) ) >> mapp.IncY;
                    _mapping[difId] = mapp;
                }
            }
            pElem = pElem->NextSiblingElement();
            // ChamberGeom  Node.
            {
                streamlog_out( DEBUG1 ) << green
                                        <<"parameter : "
                                       << pElem->Attribute("name")
                                       << normal
                                       << std::endl;
                std::vector<std::string> lines;
                {
                    std::string value = pElem->GetText() ;
                    std::vector<std::string> lines;
                    istringstream iss(value);
                    copy(istream_iterator<string>(iss),
                         istream_iterator<string>(),
                         back_inserter<vector<string> >(lines));
                    for(unsigned int iline = 0; iline < lines.size(); iline++){
                        std::string line = lines.at(iline);
                        streamlog_out( MESSAGE ) << red << line << normal << std::endl;

                        stringstream ss( line.c_str() );
                        vector<string> result;

                        double position;
                        int difId;
                        while( ss.good() )
                        {
                            string substr;
                            getline( ss, substr, ',' );
                            result.push_back( substr );
                        }
                        istringstream ( result.at(0) ) >> difId;
                        istringstream ( result.at(3) ) >> position;

                        _chamberPos[difId] = position;
                    }
                }
            }
        }
    }else{
        streamlog_out( WARNING ) << red << "Failed to load file : " << xmlfile.c_str() << normal <<std::endl;
    }
}

// ============ decode the cell ids =============
// Dif 1 => cellID0= 00983297 => DifID=1 / AsicID=1 / ChanID=15
uint Trivent::getCellDifId(int cellId){
    return cellId & 0xFF; // Applique le masque 1111 1111
}
uint Trivent::getCellAsicId(int cellId){
    return (cellId & 0xFF00)>>8; //  Applique le masque 1111 1111 0000 0000 puis tronque les 8 derniers bits
}
uint Trivent::getCellChanId(int cellId){
    return (cellId & 0x3F0000)>>16; //  Applique le masque 1111 0000 0000 0000 0000 puis tronque les 16 derniers bits
}
// ============ ============ ============ ============ ============ ============ ============ ============
// ============ ============ ============ ============ ============ ============ ============ ============
// Exemple sur Dif 1:
// cellId0 = 00983297 -> Binaire =  1111 0000 0001 0000 0001
// binaire & 0xFF = 0000 0001 => 2^0=1
// binaire & 0xFF00 = 0000 0001 0000 0000 >>8 = 0000 0001 => 2^0=1
// binaire & 0x3F0000 =  1111 0000 0000 0000 0000 >>16 = 1111 => (2^3)+(2^2)+(2^1)+(2^0)=15
// ============ ============ ============ ============ ============ ============ ============ ============
// ============ ============ ============ ============ ============ ============ ============ ============

uint* Trivent::getPadIndex(uint difId, uint asicId, uint chanId){
    m_index[0]=m_index[1]=m_index[2]=0;
    double difY = -1., difZ = -1.;
    difZ = _mapping.find(difId)->second.K;
    difY = _mapping.find(difId)->second.difY;
    m_index[0] = (1+MapILargeHR2[chanId]+AsicShiftI[asicId]);
    m_index[1] = (32-(MapJLargeHR2[chanId]+AsicShiftJ[asicId]))+int(difY);
    m_index[2] = abs(int(difZ));
    streamlog_out( DEBUG0 ) << " difId == " << difId
                            << " Asic_id ==" << asicId
                            << " Chan_id ==" << chanId
                            << " I == " << m_index[0]
                            << " J == " << m_index[1]
                            << " K == " << m_index[2]
                            << std::endl;
    return m_index;
}

//===============================================
void Trivent::getMaxTime()
{
    m_maxTime = 0;
    try{
        for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit=m_triggerRawHit.begin();rawHit!= m_triggerRawHit.end();rawHit++){
            int time =  int((*rawHit)->getTimeStamp());
            if(time >= 0) m_maxTime = max(m_maxTime, time);
        }
    }catch (std::exception ec){
        streamlog_out( WARNING )<<"No hits "<<std::endl;
    }
    streamlog_out( DEBUG1 ) << " maxtime before == " << m_maxTime << std::endl;
    //return maxtime;
}

//===============================================
std::vector<int> Trivent::getTimeSpectrum() //__attribute__((optimize(0)))
{
    std::vector<int> timeSpectrum(m_maxTime+1);
    try{
        for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit=m_triggerRawHit.begin();rawHit!= m_triggerRawHit.end();rawHit++){
            int time =  int((*rawHit)->getTimeStamp());
            if(time >= 0) timeSpectrum[time]++;
        }
    }catch (std::exception ec){
        streamlog_out( WARNING )<<"No hits "<<std::endl;
    }
    return timeSpectrum;
}

//===============================================
bool Trivent::peakOrNot(std::vector<int> timeSpectrum ,int iTime ,int threshold){

#if HISTOGRAM_PARSER
    noise_dist->Fill(timeSpectrum[iTime]);
#endif

    if(timeSpectrum[iTime] >= threshold
            && timeSpectrum[iTime] >  timeSpectrum[iTime+1]
            && timeSpectrum[iTime] >= timeSpectrum[iTime+1]){
        return true;
    }else{
        return false;
    }
}

//===============================================
int IJKToKey(const int i,const int j,const int k){return 100*100*k+100*j+i;}

//===============================================
int findAsicKey(int i,int j,int k)
{
    if(i>96||i<0||j>96||j<0) return -1;
    int jnum=(j-1)/8;
    int inum=(i-1)/8;
    int num=jnum*12+inum;
    return k*1000+num;
}

void Trivent::eventBuilder(LCCollection* colEvent,int timePeak, int previousTimePeak)
{
    _zCut.clear();

    colEvent->setFlag(colEvent->getFlag()|( 1 << LCIO::RCHBIT_LONG));
    colEvent->setFlag(colEvent->getFlag()|( 1 << LCIO::RCHBIT_TIME));
    CellIDEncoder<CalorimeterHitImpl> cd( "M:3,S-1:3,I:9,J:9,K-1:6" ,colEvent) ;
    std::map<int,int> asicMap;

    try{
        std::vector<int> hitKeys;
        int previousTime = 0;
        int cerenkovTime = 0;
        for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit=m_triggerRawHit.begin();rawHit!= m_triggerRawHit.end();rawHit++){
            float pos[3];
            int time = (*rawHit)->getTimeStamp();

            int Dif_id  =  getCellDifId ((*rawHit)->getCellID0());

            // CTag has an offset of ~5 in December 2014, 7-17 in May/April 2015
            // Need to modify the timeWin in the following loop to analyse it
            if (Dif_id == m_cerenkovDifId) m_timeWindow = m_cerenkovWindow;
            else m_timeWindow = 2;

            if(fabs(time-timePeak) <= m_timeWindow &&
                    (time > previousTimePeak + m_timeWindow ))
            {
                int Asic_id =  getCellAsicId((*rawHit)->getCellID0());
                int Chan_id =  getCellChanId((*rawHit)->getCellID0());

                std::vector<dqm4hep::dqm_uint> padIndex = getPadIndex(Dif_id, Asic_id, Chan_id);

                dqm4hep::dqm_uint I = padIndex[0];
                dqm4hep::dqm_uint J = padIndex[1];
                dqm4hep::dqm_uint K = padIndex[2];

                // Find and remove square events
                int asicKey = findAsicKey(I,J,K);
                if(asicMap[asicKey]) asicMap[asicKey]++;
                else asicMap[asicKey]=1;
                if( asicMap[asicKey]==64 ){
                    _zCut.clear();
                    hitKeys.clear();
                    asicMap.clear();
                    return;
                }

                int aHitKey=IJKToKey(I,J,K);
                pos[0] = I*10.*1.04125;
                pos[1] = J*10.*1.04125;
                pos[2] = K*26.131;

                // If No more CTag Reset it to 0
                if ( cerenkovTime - previousTime > 1)
                {
                    streamlog_out ( DEBUG0 ) << red << "cerenkovTime - previousTime: " << cerenkovTime - previousTime << normal << std::endl;
                    m_cerenkovFlag[0] = m_cerenkovFlag[1] = m_cerenkovFlag[2] = 0;
                    m_cerenkovCount[0] = m_cerenkovCount[1] = m_cerenkovCount[2] = 0;
                }

                // Treat CTag
                if (Dif_id == m_cerenkovDifId)
                {
                    cerenkovTime = time;
                    streamlog_out ( MESSAGE ) << green << "Event #: " << m_evtNbr << "\tTrigger #: " << m_trigCount <<  \
                                                 "\tDelta t:" << time - timePeak << "\tAt Time:" << time << "\tMaxTime: " << m_maxTime << "\t MaxTime - CeremkovTime: " << m_maxTime - time << normal << std::endl;

                    unsigned short cerenkovAmplitude = (*rawHit)->getAmplitude();
                    streamlog_out( MESSAGE ) << blue << "CTag amplitude: " << cerenkovAmplitude << normal << std::endl;

                    // In december 2014 only one Cerenkov was used and its signal spanned on 4-5times slot
                    // Need to be treated separately to not count the CTag multiple time
                    // Besides in Decmeber cerenkovAmplitude for the CTag is equal to 5
                    if (cerenkovAmplitude == 5)
                    {
                        m_cerenkovCount[2]++;
                        m_cerenkovCountTotal[2]++;
                        if (m_cerenkovFlag[2] == 0) m_cerenkovFlag[2] = 1;
                    }
                    else if (cerenkovAmplitude<3) // In may/April 2015 2 Cerenkov. cerenkovAmplitude = 1 = CTag1
                        //                                                             = 2 = CTag2
                        //                                                             = 3 = CTag1 + CTag2
                    {
                        m_cerenkovCount[cerenkovAmplitude-1]++;
                        m_cerenkovCountTotal[cerenkovAmplitude-1]++;
                        if (m_cerenkovFlag[cerenkovAmplitude-1] == 0) m_cerenkovFlag[cerenkovAmplitude-1] = 1;
                    }
                }

                if(K<=0||K>64)
                {
                    streamlog_out( MESSAGE ) << " Dif_id  == " << Dif_id
                                             << " Asic_id == " << Asic_id
                                             << " Chan_id == " << Chan_id
                                             << " I == " << I
                                             << " J == " << J
                                             << " K == " << K
                                             << std::endl;
                    continue;
                }

                x.push_back( pos[0] );
                y.push_back( pos[1] );
                z.push_back( pos[2] );
                fThr.push_back( int((*rawHit)->getAmplitude()) );
                fDifId.push_back( Dif_id );
                fTime.push_back( time );
                fPrevTime.push_back( prevTime );
                fTimePeak.push_back( timePeak );
                fPrevTimePeak.push_back( previousTimePeak  );
                fDeltaTimePeak.push_back( time - timePeak );
                fNevt.push_back( m_evtNbr );

                streamlog_out ( DEBUG0 ) << green << "Evt: " << m_evtNbr << "\t Previous: " << m_previousEvtNbr << normal << std::endl;
                if ( m_evtNbr == m_previousEvtNbr ) fEvtReconstructed.push_back( 0 ); // To have only 1 entry per evt reconstructed and not the hit number
                else                         fEvtReconstructed.push_back( m_evtNbr );

                fTriggerNr.push_back( m_trigCount );
                fNhit.push_back( colEvent->getNumberOfElements() );
                fCerenkovTag1.push_back( m_cerenkovFlag[0] );
                fCerenkovTag2.push_back( m_cerenkovFlag[1] );
                fCerenkovTag3.push_back( m_cerenkovFlag[2] );
                fCerenkovCount1.push_back ( m_cerenkovCount[0] );
                fCerenkovCount2.push_back ( m_cerenkovCount[1] );
                fCerenkovCount3.push_back ( m_cerenkovCount[2] );

                if (m_cerenkovCount[2] == 4)                      //True CTag in December span over 5clocks
                    fCerenkovCountDecember.push_back( 1 );
                else
                    fCerenkovCountDecember.push_back( 0 );

                CalorimeterHitImpl* caloHit = new CalorimeterHitImpl();
                caloHit->setTime(float((*rawHit)->getTimeStamp()));

                if(float((*rawHit)->getAmplitude()&3)>2.5) caloHit->setEnergy(float((*rawHit)->getAmplitude()&3));         // 3rd treshold
                else if(float((*rawHit)->getAmplitude()&3)>1.5) caloHit->setEnergy(float((*rawHit)->getAmplitude()&3)-1);  // 2nd treshold -1 to shift color to green
                else caloHit->setEnergy(float((*rawHit)->getAmplitude()&3)+1);                                             // 1st treshold +1 to shift color to blue

                //avoid two hit in the same cell
                if(std::find(hitKeys.begin(),hitKeys.end(),aHitKey)!=hitKeys.end())
                {
                    IMPL::CalorimeterHitImpl* hit =
                            dynamic_cast<IMPL::CalorimeterHitImpl*>(colEvent->getElementAt(std::distance(hitKeys.begin(),std::find(hitKeys.begin(),hitKeys.end(),aHitKey))));
                    float hitTime = hit->getTime();
                    if( fabs(timePeak - hitTime) > fabs( timePeak - time ))
                    {
                        hit->setEnergy(caloHit->getEnergy());
                    }
                    continue;
                }

                // set the cell id
                cd["I"] = I ;
                cd["J"] = J ;
                cd["K-1"] = K-1 ;
                cd["M"] = 0 ;
                cd["S-1"] = 3 ;
                streamlog_out( DEBUG0 ) << " I == " << I
                                        << " J == " << J
                                        << " K == " << K
                                        << std::endl;
                cd.setCellID( caloHit ) ;
                if(std::find(_zCut.begin(), _zCut.end(), K)==_zCut.end())
                    _zCut.push_back(K);
                caloHit->setPosition(pos);
                colEvent->addElement(caloHit);
                hitKeys.push_back(aHitKey);

                streamlog_out ( DEBUG0 ) << red << "Evt: " << m_evtNbr << "\t Previous: " << m_previousEvtNbr << normal << std::endl;
                m_previousEvtNbr = m_evtNbr;
                streamlog_out ( DEBUG0 ) << yellow << "Evt: " << m_evtNbr << "\t Previous: " << m_previousEvtNbr << normal << std::endl;
            } // End if (timeWin)
            prevTime = time;
        }//loop over the hit
        hitKeys.clear();
    }catch(DataNotAvailableException &e){
        streamlog_out(WARNING) << " collection not available" << std::endl;
    }
}

//===============================================
void Trivent::init() {
    m_trigCount = 0;
    m_cerenkovFlag[0] = m_cerenkovFlag[1] = m_cerenkovFlag[2] = 0;
    m_cerenkovCount[0] = m_cerenkovCount[1] = m_cerenkovCount[2] = 0;
    m_cerenkovCountTotal[0] = m_cerenkovCountTotal[1] = m_cerenkovCountTotal[2] = 0;
    //========================
    //readDifGeomFile(_mappingfile.c_str());

    // ========================

    printParameters();
    // new process

    XMLReader(m_geomXMLFile.c_str());
    m_evtNbr = 0;// event number
    m_previousEvtNbr = 0;
}

//==================================================================================
void Trivent::processRunHeader( LCRunHeader * runHd ) {
}

//==================================================================================
dqm4hep::StatusCode Trivent::processEvent(EVENT::LCEvent *pLCEvent)
{
    if (NULL == pLCEvent)
        return dqm4hep::STATUS_CODE_FAILURE;

    m_evtNbr = pLCEvent->getEventNumber();
    for(unsigned int i=0; i< m_hcalCollections.size(); i++)//!loop over collection
    {
        // Grab the input collection
        EVENT::LCCollection * pLCCollection = NULL;

        try
        {
            pLCCollection = pLCEvent ->getCollection(m_hcalCollections[i].c_str());
        }
        catch (lcio::DataNotAvailableException &exception)
        {
            return dqm4hep::STATUS_CODE_NOT_FOUND;
        }

        if(NULL == pLCCollection)
            return dqm4hep::STATUS_CODE_FAILURE;

        int numberOfHits = pLCCollection->getNumberOfElements(); // hit number
        m_trigCount++;

        // If numberOfHit too large do not process the event
        if(numberOfHits > m_elecNoiseCut)  {
            streamlog_out( MESSAGE ) << "TRIGGER SKIPED ... NoiseCut" << std::endl;
            break;
        }

        // set raw hits
        m_triggerRawHit.clear();
        m_cerenkovHits.clear();
        std::vector<int> vTrigger;

        for (int iHit(0); iHit < numberOfHits; ++iHit) // loop over the hits
        {
            EVENT::RawCalorimeterHit *pRawHit = dynamic_cast<EVENT::RawCalorimeterHit*>( pLCCollection->getElementAt(iHit));

            if(NULL == pRawHit)
                return dqm4hep::STATUS_CODE_FAILURE;

            // Get the difId
            unsigned int difId = pRawHit->getCellID0()&0xFF;

            // Extract abolute bcid information:
            if(iHit == 0)
            {
                if (difId == 0) continue;

                std::stringstream pname("");
                pname << "DIF" << difId << "_Triggers";

                pLCCollection->getParameters().getIntVals(pname.str(),vTrigger);
                if (vTrigger.size()!=0)
                {
                    m_bcid1 = vTrigger[4]; // absoluteBCID/(0xFFFFFF+1))&0xFFFFFF;
                    m_bcid2 = vTrigger[3]; // absoluteBCID&0xFFFFFF;

                    //Shift the value from the 24 first bits
                    unsigned long long Shift = 16777216ULL;
                    unsigned long long theBCID_ = m_bcid1*Shift + m_bcid2;
                    streamlog_out( DEBUG1 ) << "trigger time : " << theBCID_ << std::endl;
                }
            }
            m_triggerRawHit.push_back(pRawHit);
        }
        getMaxTime();
        std::vector<int> timeSpectrum = getTimeSpectrum();

        //---------------------------------------------------------------
        //! Find the candidate event
        //!
        int iBin=0; // The bin number
        int previousBin = 0;

        while(iBin < (m_maxTime+1))
        {
            if(timeSpectrum[iBin] >= m_noiseCut                &&
                    timeSpectrum[iBin] >= timeSpectrum[iBin+2] &&
                    timeSpectrum[iBin] >= timeSpectrum[iBin+1] &&
                    timeSpectrum[iBin] >= timeSpectrum[iBin-1] &&
                    timeSpectrum[iBin] >= timeSpectrum[iBin-2]
                    )
            {
                IMPL::LCEventImpl*  pEvt = new IMPL::LCEventImpl() ;     // create the event

                //---------- set event paramters ------
                const std::string parname_trigger = "trigger";
                const std::string parname_energy  = "beamEnergy";
                const std::string parname_bcid1 = "bcid1";
                const std::string parname_bcid2 = "bcid2";
                const std::string parname_cerenkov1 = "cerenkov1"; // First Cerenkov in April/May 2015
                const std::string parname_cerenkov2 = "cerenkov2"; // Second Cerenkov in April/May 2015
                const std::string parname_cerenkov3 = "cerenkov3"; // Both Cerenkov in April/May 2015 + Cerenkov in December 2014

                pEvt->parameters().setValue(parname_trigger,pLCEvent->getEventNumber());
                pEvt->parameters().setValue(parname_energy , m_beamEnergy);
                pEvt->parameters().setValue(parname_bcid1 , m_bcid1);
                pEvt->parameters().setValue(parname_bcid2 , m_bcid2);
                pEvt->setRunNumber( pLCEvent->getRunNumber()) ;

                //-------------------------------------
                IMPL::LCCollectionVec* pCalorimeterHitCollection = new IMPL::LCCollectionVec(EVENT::LCIO::CALORIMETERHIT);

                m_evtNbr++;
                m_cerenkovCount[0] = m_cerenkovCount[1] = m_cerenkovCount[2] = 0;

                Trivent::eventBuilder(pCalorimeterHitCollection, iBin, previousBin);
                pEvt->parameters().setValue(parname_cerenkov1, m_cerenkovCount[0]); // Value determined in the eventBuilder
                pEvt->parameters().setValue(parname_cerenkov2, m_cerenkovCount[1]); // Value determined in the eventBuilder
                pEvt->parameters().setValue(parname_cerenkov3, m_cerenkovCount[2]); // Value determined in the eventBuilder
                // ->Need to be after the EventBuilder function

                if( (int)_zCut.size() >m_layerCut &&                                  // the min layer numb cut
                        abs( iBin - previousBin) > m_time2PreviousEventCut)// time2prev event  cut
                {

                    pEvt->setEventNumber( m_evtNbr ) ;

                    // Add the collection to the event
                    try
                    {
                        pEvt->addCollection(pCalorimeterHitCollection, m_outputCollectionName);
                    }
                    catch(IO::IOException &exception)
                    {
                        delete pCalorimeterHitCollection;
                        return dqm4hep::STATUS_CODE_ALREADY_PRESENT;
                    }
                    evts.push_back(pEvt);
                    m_selectedEvt++;
                }
                else
                {
                    m_rejectedEvt++;
                    delete pCalorimeterHitCollection; pCalorimeterHitCollection = NULL;
                }
                previousBin = iBin;
                iBin = iBin + m_timeWindow;
                delete pEvt; pEvt=NULL;
            }
            else
            {
                iBin++;
            }
        }
    } // Loop on the collection

    return dqm4hep::STATUS_CODE_SUCCESS;
}
//==============================================================
void Trivent::end()
{
    streamlog_out( MESSAGE ) << "Trivent Rejected " << m_rejectedEvt << " Candidate event" << std::endl;
    streamlog_out( MESSAGE ) << "Trivent Selected " << m_selectedEvt << " Candidate event" << std::endl;
    streamlog_out( MESSAGE ) << " ====== Trivent end ======" << std::endl;
    streamlog_out( MESSAGE ) << "Total Cerenkov1 Tags: " << m_cerenkovCountTotal[0] << std::endl;
    streamlog_out( MESSAGE ) << "Total Cerenkov2 Tags: " << m_cerenkovCountTotal[1] << std::endl;
    streamlog_out( MESSAGE ) << "Total Cerenkov3 Tags: " << m_cerenkovCountTotal[2] << std::endl;
}

//==============================================================

void Trivent::setInputCollectionName(const std::string &inputCollectionName)
{
    m_inputCollectionName = inputCollectionName;
}

void Trivent::setOutputCollectionName(const std::string &outputCollectionName)
{
    m_outputCollectionName = outputCollectionName;
}

void Trivent::setOutputFileName(const std::string &outputFileName)
{
    m_outputFileName = outputFileName;
}

void Trivent::setOutputNoiseFileName(const std::string &noiseFileName)
{
    m_noiseFileName = noiseFileName;
}

void Trivent::setGeometryXMLFile(const std::string &geomXMLFile)
{
    m_geomXMLFile = geomXMLFile;
}

void Trivent::setLayerCut(const int &layerCut)
{
    m_layerCut = layerCut;
}

void Trivent::setNoiseCut(const int &noiseCut)
{
    m_noiseCut = noiseCut;
}

void Trivent::setTimeWindow(const int &timeWindow)
{
    m_timeWindow = timeWindow;
}

void Trivent::setLayerGap(const double &layerGap)
{
    m_layerGap = layerGap;
}

void Trivent::setElecNoiseCut(const int &elecNoiseCut)
{
    m_elecNoiseCut = elecNoiseCut;
}

void Trivent::setTime2PreviousEventCut(const int &time2PreviousEventCut)
{
    m_time2PreviousEventCut = time2PreviousEventCut;
}

void Trivent::setGainCorrectionMode(const bool gainCorrectionMode)
{
    m_gainCorrectionMode = gainCorrectionMode;
}

void Trivent::setCerenkovWindow(const int cerenkovWindow)
{
    m_cerenkovWindow = cerenkovWindow;
}

void Trivent::setCerenkovLength(const int cerenkovLength)
{
    m_cerenkovLength = cerenkovLength;
}

void Trivent::setCerenkovDifId(const int cerenkovDifId)
{
    m_cerenkovDifId = cerenkovDifId;
}


}
