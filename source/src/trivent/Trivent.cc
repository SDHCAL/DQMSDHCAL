/// \file Streamout.cc
/*
*
* Streamout.cc source template automatically generated by a class generator
* Creation date : lun. aoï¿½t 3 2015
*
* This file is part of DQMSDHCAL libraries.
*
* DQMSDHCAL is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* DQMSDHCAL is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Yacine Haddad, Arnaud Steen, Remi Ete, Antoine Pingault
* @copyright CNRS , IPNL, UGent
*/

// -- dqm sdhcal headers
#include <dqmsdhcal/trivent/Trivent.h>

// -- lcio headers
#include <EVENT/LCIO.h>
#include <EVENT/LCCollection.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCEventImpl.h>
#include <EVENT/LCFloatVec.h>
#include <EVENT/LCParameters.h>
#include <UTIL/CellIDEncoder.h>



#include <limits.h>
#include <cmath>
#include <stdexcept>
#include <Rtypes.h>
#include <sstream>


#include "TObject.h"
#include "TRefArray.h"
#include "TRef.h"
#include <fstream>
#include <algorithm>

namespace dqm_sdhcal
{


Trivent::Trivent():
    m_inputCollectionName("DHCALRawHits"),
    m_outputCollectionName("SDHCAL_HIT"),
    m_noiseFileName("noise_run.slcio"),
    m_layerCut(10),
    m_noiseCut(10),
    m_timeWindow(2),
    m_geomXMLFile("setup_geometry.xml"),
    m_layerGap(.9),
    m_elecNoiseCut(100000),
    m_time2PreviousEventCut(0),
    m_gainCorrectionMode(false),
    m_cerenkovWindow(20),
    m_cerenkovLength(1),
    m_cerenkovDifId(3),
    m_rejectedEvt(0),
    m_selectedEvt(0)
{

}

Trivent::Trivent():
    _output(0),
    _runNbr(0),
    _eventType(0),
    _evtId(0)
{
}

void Trivent::XMLReader(std::string xmlfile){
    TiXmlDocument doc(xmlfile.c_str());
    bool load_key = doc.LoadFile();
    if(load_key){
        streamlog_out( MESSAGE ) << green << "File : " << xmlfile.c_str() << normal <<std::endl;
        // tout ici
        TiXmlHandle hDoc(&doc);
        TiXmlElement* pElem;
        TiXmlHandle hRoot(0);
        // name block
        {
            pElem=hDoc.FirstChildElement().Element();
            // should always have a valid root but handle gracefully if it does
            if (!pElem) streamlog_out( WARNING ) << red << "error elem" << normal << std::endl;
            streamlog_out( MESSAGE ) << green << pElem->Value() << normal << std::endl;

            // save this for later
            hRoot=TiXmlHandle(pElem);
        }
        // parameters block
        {
            m_parameters.clear();
            pElem=hRoot.FirstChild("parameter").Element();
            std::string key = pElem->Attribute("name");
            streamlog_out( MESSAGE ) << green << key.c_str() << normal << std::endl;
            streamlog_out( DEBUG1 ) << green
                                    <<"parameter : "
                                   << pElem->Attribute("name")
                                   << normal
                                   << std::endl;

            std::vector<std::string> lines;
            {
                std::string value = pElem->GetText() ;
                std::vector<std::string> lines;
                istringstream iss(value);
                copy(istream_iterator<string>(iss),
                     istream_iterator<string>(),
                     back_inserter<vector<string> >(lines));
                for(unsigned int iline = 0; iline < lines.size(); iline++){
                    std::string line = lines.at(iline);
                    streamlog_out( MESSAGE ) << red << line << normal << std::endl;

                    stringstream ss( line.c_str() );
                    vector<string> result;

                    LayerID mapp;
                    int difId;
                    while( ss.good() )
                    {
                        string substr;
                        getline( ss, substr, ',' );
                        result.push_back( substr );
                    }
                    istringstream ( result.at(0) ) >> difId;
                    istringstream ( result.at(1) ) >> mapp.K;
                    istringstream ( result.at(2) ) >> mapp.DifX;
                    istringstream ( result.at(3) ) >> mapp.DifY;
                    istringstream ( result.at(4) ) >> mapp.IncX;
                    istringstream ( result.at(5) ) >> mapp.IncY;
                    _mapping[difId] = mapp;
                }
            }
            pElem = pElem->NextSiblingElement();
            // ChamberGeom  Node.
            {
                streamlog_out( DEBUG1 ) << green
                                        <<"parameter : "
                                       << pElem->Attribute("name")
                                       << normal
                                       << std::endl;
                std::vector<std::string> lines;
                {
                    std::string value = pElem->GetText() ;
                    std::vector<std::string> lines;
                    istringstream iss(value);
                    copy(istream_iterator<string>(iss),
                         istream_iterator<string>(),
                         back_inserter<vector<string> >(lines));
                    for(unsigned int iline = 0; iline < lines.size(); iline++){
                        std::string line = lines.at(iline);
                        streamlog_out( MESSAGE ) << red << line << normal << std::endl;

                        stringstream ss( line.c_str() );
                        vector<string> result;

                        double position;
                        int difId;
                        while( ss.good() )
                        {
                            string substr;
                            getline( ss, substr, ',' );
                            result.push_back( substr );
                        }
                        istringstream ( result.at(0) ) >> difId;
                        istringstream ( result.at(3) ) >> position;

                        _chamberPos[difId] = position;
                    }
                }
            }
        }
    }else{
        streamlog_out( WARNING ) << red << "Failed to load file : " << xmlfile.c_str() << normal <<std::endl;
    }
}

void Trivent::readDifGeomFile(std::string geomfile){

    cout << "read the mapping file .."<< endl;

    LayerID contenu;
    ifstream file(geomfile.c_str(), ios::in);
    if(file){
        while(!file.eof()){
            int difId;
            char co;
            file >> difId >> co
                    >> contenu.K >> co
                    >> contenu.DifX >> co
                    >> contenu.DifY >> co
                    >> contenu.IncX >> co
                    >> contenu.IncY ;
            _mapping [difId] = contenu;
        }
        file.close();
    }
    else
        cerr << "ERROR ... maping file not correct !" << endl;
}

void Trivent::printDifGeom(){

    for(std::map<int,LayerID>::iterator itt = _mapping.begin();itt!=_mapping.end();itt++)     {
        streamlog_out( MESSAGE ) << itt->first << "\t" << itt->second.K
                                 <<"\t"<<itt->second.DifX
                                <<"\t"<<itt->second.DifY
                               <<"\t"<<itt->second.IncX
                              <<"\t"<<itt->second.IncY
                             << std::endl;
    }
}

// ============ decode the cell ids =============
// Dif 1 => cellID0= 00983297 => DifID=1 / AsicID=1 / ChanID=15
uint Trivent::getCellDifId(int cellId){
    return cellId & 0xFF; // Applique le masque 1111 1111
}
uint Trivent::getCellAsicId(int cellId){
    return (cellId & 0xFF00)>>8; //  Applique le masque 1111 1111 0000 0000 puis tronque les 8 derniers bits
}
uint Trivent::getCellChanId(int cellId){
    return (cellId & 0x3F0000)>>16; //  Applique le masque 1111 0000 0000 0000 0000 puis tronque les 16 derniers bits
}
// ============ ============ ============ ============ ============ ============ ============ ============
// ============ ============ ============ ============ ============ ============ ============ ============
// Exemple sur Dif 1:
// cellId0 = 00983297 -> Binaire =  1111 0000 0001 0000 0001
// binaire & 0xFF = 0000 0001 => 2^0=1
// binaire & 0xFF00 = 0000 0001 0000 0000 >>8 = 0000 0001 => 2^0=1
// binaire & 0x3F0000 =  1111 0000 0000 0000 0000 >>16 = 1111 => (2^3)+(2^2)+(2^1)+(2^0)=15
// ============ ============ ============ ============ ============ ============ ============ ============
// ============ ============ ============ ============ ============ ============ ============ ============

uint* Trivent::getPadIndex(uint difId, uint asicId, uint chanId){
    m_index[0]=m_index[1]=m_index[2]=0;
    double difY = -1., difZ = -1.;
    difZ = _mapping.find(difId)->second.K;
    difY = _mapping.find(difId)->second.difY;
    m_index[0] = (1+MapILargeHR2[chanId]+AsicShiftI[asicId]);
    m_index[1] = (32-(MapJLargeHR2[chanId]+AsicShiftJ[asicId]))+int(difY);
    m_index[2] = abs(int(difZ));
    streamlog_out( DEBUG0 ) << " difId == " << difId
                            << " Asic_id ==" << asicId
                            << " Chan_id ==" << chanId
                            << " I == " << m_index[0]
                            << " J == " << m_index[1]
                            << " K == " << m_index[2]
                            << std::endl;
    return m_index;
}

//===============================================
void Trivent::getMaxTime()
{
    m_maxTime = 0;
    try{
        for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit=m_triggerRawHit.begin();rawHit!= m_triggerRawHit.end();rawHit++){
            int time =  int((*rawHit)->getTimeStamp());
            if(time >= 0) m_maxTime = max(m_maxTime, time);
        }
    }catch (std::exception ec){
        streamlog_out( WARNING )<<"No hits "<<std::endl;
    }
    streamlog_out( DEBUG1 ) << " maxtime before == " << m_maxTime << std::endl;
    //return maxtime;
}

//===============================================
std::vector<int> Trivent::getTimeSpectrum() //__attribute__((optimize(0)))
{
    std::vector<int> timeSpectrum(m_maxTime+1);
    try{
        for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit=m_triggerRawHit.begin();rawHit!= m_triggerRawHit.end();rawHit++){
            int time =  int((*rawHit)->getTimeStamp());
            if(time >= 0) timeSpectrum[time]++;
        }
    }catch (std::exception ec){
        streamlog_out( WARNING )<<"No hits "<<std::endl;
    }
    return timeSpectrum;
}

//===============================================
bool Trivent::peakOrNot(std::vector<int> timeSpectrum ,int iTime ,int threshold){

#if HISTOGRAM_PARSER
    noise_dist->Fill(timeSpectrum[iTime]);
#endif

    if(timeSpectrum[iTime] >= threshold
            && timeSpectrum[iTime] >  timeSpectrum[iTime+1]
            && timeSpectrum[iTime] >= timeSpectrum[iTime+1]){
        return true;
    }else{
        return false;
    }
}

//===============================================
int IJKToKey(const int i,const int j,const int k){return 100*100*k+100*j+i;}

//===============================================
int findAsicKey(int i,int j,int k)
{
    if(i>96||i<0||j>96||j<0) return -1;
    int jnum=(j-1)/8;
    int inum=(i-1)/8;
    int num=jnum*12+inum;
    return k*1000+num;
}

void Trivent::eventBuilder(LCCollection* colEvent,int timePeak, int previousTimePeak){
    _zCut.clear();

    colEvent->setFlag(colEvent->getFlag()|( 1 << LCIO::RCHBIT_LONG));
    colEvent->setFlag(colEvent->getFlag()|( 1 << LCIO::RCHBIT_TIME));
    CellIDEncoder<CalorimeterHitImpl> cd( "M:3,S-1:3,I:9,J:9,K-1:6" ,colEvent) ;
    std::map<int,int> asicMap;

    try{
        std::vector<int> hitKeys;
        int previousTime = 0;
        int cerenkovTime = 0;
        for(std::vector<EVENT::RawCalorimeterHit*>::iterator rawHit=m_triggerRawHit.begin();rawHit!= m_triggerRawHit.end();rawHit++){
            float pos[3];
            int time = (*rawHit)->getTimeStamp();

            int Dif_id  =  getCellDifId ((*rawHit)->getCellID0());

            // CTag has an offset of ~5 in December 2014, 7-17 in May/April 2015
            // Need to modify the timeWin in the following loop to analyse it
            if (Dif_id == m_cerenkovDifId) m_timeWindow = m_cerenkovWindow;
            else m_timeWindow = 2;

            if(fabs(time-timePeak) <= m_timeWindow &&
                    (time > previousTimePeak + m_timeWindow ))
            {
                int Asic_id =  getCellAsicId((*rawHit)->getCellID0());
                int Chan_id =  getCellChanId((*rawHit)->getCellID0());

                uint I = getPadIndex(Dif_id, Asic_id, Chan_id)[0];
                uint J = getPadIndex(Dif_id, Asic_id, Chan_id)[1];
                uint K = getPadIndex(Dif_id, Asic_id, Chan_id)[2];

                // Find and remove square events
                int asicKey = findAsicKey(I,J,K);
                if(asicMap[asicKey]) asicMap[asicKey]++;
                else asicMap[asicKey]=1;
                if( asicMap[asicKey]==64 ){
                    _zCut.clear();
                    hitKeys.clear();
                    asicMap.clear();
                    return;
                }

                int aHitKey=IJKToKey(I,J,K);
                pos[0] = I*10.*1.04125;
                pos[1] = J*10.*1.04125;
                pos[2] = K*26.131;

                // If No more CTag Reset it to 0
                if ( cerenkovTime - previousTime > 1)
                {
                    streamlog_out ( DEBUG0 ) << red << "cerenkovTime - previousTime: " << cerenkovTime - previousTime << normal << std::endl;
                    m_cerenkovFlag[0] = m_cerenkovFlag[1] = m_cerenkovFlag[2] = 0;
                    m_cerenkovCount[0] = m_cerenkovCount[1] = m_cerenkovCount[2] = 0;
                }

                // Treat CTag
                if (Dif_id == m_cerenkovDifId)
                {
                    cerenkovTime = time;
                    streamlog_out ( MESSAGE ) << green << "Event #: " << m_evtNbr << "\tTrigger #: " << m_trigCount <<  \
                                                 "\tDelta t:" << time - timePeak << "\tAt Time:" << time << "\tMaxTime: " << m_maxTime << "\t MaxTime - CeremkovTime: " << m_maxTime - time << normal << std::endl;

                    unsigned short cerenkovAmplitude = (*rawHit)->getAmplitude();
                    streamlog_out( MESSAGE ) << blue << "CTag amplitude: " << cerenkovAmplitude << normal << std::endl;

                    // In december 2014 only one Cerenkov was used and its signal spanned on 4-5times slot
                    // Need to be treated separately to not count the CTag multiple time
                    // Besides in Decmeber cerenkovAmplitude for the CTag is equal to 5
                    if (cerenkovAmplitude == 5)
                    {
                        m_cerenkovCount[2]++;
                        m_cerenkovCountTotal[2]++;
                        if (m_cerenkovFlag[2] == 0) m_cerenkovFlag[2] = 1;
                    }
                    else if (cerenkovAmplitude<3) // In may/April 2015 2 Cerenkov. cerenkovAmplitude = 1 = CTag1
                        //                                                             = 2 = CTag2
                        //                                                             = 3 = CTag1 + CTag2
                    {
                        m_cerenkovCount[cerenkovAmplitude-1]++;
                        m_cerenkovCountTotal[cerenkovAmplitude-1]++;
                        if (m_cerenkovFlag[cerenkovAmplitude-1] == 0) m_cerenkovFlag[cerenkovAmplitude-1] = 1;
                    }
                }

                if(K<=0||K>64)
                {
                    streamlog_out( MESSAGE ) << " Dif_id  == " << Dif_id
                                             << " Asic_id == " << Asic_id
                                             << " Chan_id == " << Chan_id
                                             << " I == " << I
                                             << " J == " << J
                                             << " K == " << K
                                             << std::endl;
                    continue;
                }

                x.push_back( pos[0] );
                y.push_back( pos[1] );
                z.push_back( pos[2] );
                fThr.push_back( int((*rawHit)->getAmplitude()) );
                fDifId.push_back( Dif_id );
                fTime.push_back( time );
                fPrevTime.push_back( prevTime );
                fTimePeak.push_back( timePeak );
                fPrevTimePeak.push_back( previousTimePeak  );
                fDeltaTimePeak.push_back( time - timePeak );
                fNevt.push_back( m_evtNbr );

                streamlog_out ( DEBUG0 ) << green << "Evt: " << m_evtNbr << "\t Previous: " << m_previousEvtNbr << normal << std::endl;
                if ( m_evtNbr == m_previousEvtNbr ) fEvtReconstructed.push_back( 0 ); // To have only 1 entry per evt reconstructed and not the hit number
                else                         fEvtReconstructed.push_back( m_evtNbr );

                fTriggerNr.push_back( m_trigCount );
                fNhit.push_back( colEvent->getNumberOfElements() );
                fCerenkovTag1.push_back( m_cerenkovFlag[0] );
                fCerenkovTag2.push_back( m_cerenkovFlag[1] );
                fCerenkovTag3.push_back( m_cerenkovFlag[2] );
                fCerenkovCount1.push_back ( m_cerenkovCount[0] );
                fCerenkovCount2.push_back ( m_cerenkovCount[1] );
                fCerenkovCount3.push_back ( m_cerenkovCount[2] );

                if (m_cerenkovCount[2] == 4)                      //True CTag in December span over 5clocks
                    fCerenkovCountDecember.push_back( 1 );
                else
                    fCerenkovCountDecember.push_back( 0 );

                CalorimeterHitImpl* caloHit = new CalorimeterHitImpl();
                caloHit->setTime(float((*rawHit)->getTimeStamp()));

                if(float((*rawHit)->getAmplitude()&3)>2.5) caloHit->setEnergy(float((*rawHit)->getAmplitude()&3));         // 3rd treshold
                else if(float((*rawHit)->getAmplitude()&3)>1.5) caloHit->setEnergy(float((*rawHit)->getAmplitude()&3)-1);  // 2nd treshold -1 to shift color to green
                else caloHit->setEnergy(float((*rawHit)->getAmplitude()&3)+1);                                             // 1st treshold +1 to shift color to blue

                //avoid two hit in the same cell
                if(std::find(hitKeys.begin(),hitKeys.end(),aHitKey)!=hitKeys.end())
                {
                    IMPL::CalorimeterHitImpl* hit =
                            dynamic_cast<IMPL::CalorimeterHitImpl*>(colEvent->getElementAt(std::distance(hitKeys.begin(),std::find(hitKeys.begin(),hitKeys.end(),aHitKey))));
                    float hitTime = hit->getTime();
                    if( fabs(timePeak-hitTime)>fabs(timePeak-time) )
                    {
                        hit->setEnergy(caloHit->getEnergy());
                    }
                    continue;
                }

                // set the cell id
                cd["I"] = I ;
                cd["J"] = J ;
                cd["K-1"] = K-1 ;
                cd["M"] = 0 ;
                cd["S-1"] = 3 ;
                streamlog_out( DEBUG0 ) << " I == " << I
                                        << " J == " << J
                                        << " K == " << K
                                        << std::endl;
                cd.setCellID( caloHit ) ;
                if(std::find(_zCut.begin(), _zCut.end(), K)==_zCut.end())
                    _zCut.push_back(K);
                caloHit->setPosition(pos);
                colEvent->addElement(caloHit);
                hitKeys.push_back(aHitKey);

                streamlog_out ( DEBUG0 ) << red << "Evt: " << m_evtNbr << "\t Previous: " << _previousEvtNbr << normal << std::endl;
                _previousEvtNbr=m_evtNbr;
                streamlog_out ( DEBUG0 ) << yellow << "Evt: " << m_evtNbr << "\t Previous: " << _previousEvtNbr << normal << std::endl;
            } // End if (timeWin)
            prevTime = time;
        }//loop over the hit
        hitKeys.clear();
    }catch(DataNotAvailableException &e){
        streamlog_out(WARNING) << " collection not available" << std::endl;
    }
}

//===============================================
void Trivent::init() {
    m_trigCount = 0;
    _cerenkovFlag[0] = _cerenkovFlag[1] = _cerenkovFlag[2] = 0;
    _cerenkovCount[0] = _cerenkovCount[1] = _cerenkovCount[2] = 0;
    _cerenkovCountTotal[0] = _cerenkovCountTotal[1] = _cerenkovCountTotal[2] = 0;
    //========================
    //readDifGeomFile(_mappingfile.c_str());

    // ========================

    printParameters();
    // new process

    char cnormal[8] =  {0x1b,'[','0',';','3','9','m',0};
    char cred[8]     = {0x1b,'[','1',';','3','1','m',0};
    char cgreen[8]   = {0x1b,'[','1',';','3','2','m',0};
    char cyellow[8]  = {0x1b,'[','1',';','3','3','m',0};
    char cblue[8]    = {0x1b,'[','1',';','3','4','m',0};
    char cmagenta[8] = {0x1b,'[','1',';','3','5','m',0};
    char cwhite[8]   = {0x1b,'[','1',';','3','9','m',0};

    normal   = cnormal;
    red      = cred;
    green    = cgreen;
    yellow   = cyellow;
    blue     = cblue;
    magenta  = cmagenta;
    white    = cwhite;

    _lcWriter = LCFactory::getInstance()->createLCWriter() ;
    _lcWriter->setCompressionLevel( 0 ) ;
    _lcWriter->open(_outFileName.c_str(),LCIO::WRITE_NEW) ;


    XMLReader(m_geomXMLFile.c_str());
    printDifGeom();
    m_evtNbr=0;// event number
    _previousEvtNbr =0;

    // ROOT File Creation
    _file = new TFile(_rootFileName.c_str(),"RECREATE");
    _tree = (TTree*)_file->Get("_tree");
    if(!_tree)
    {
        std::cout << "tree creation" << std::endl;
        _tree = new TTree("_treeName","Shower variables");
    }

    // Root Branches
    _tree->Branch("X","std::vector<int>",&x);
    _tree->Branch("Y","std::vector<int>",&y);
    _tree->Branch("Z","std::vector<int>",&z);
    _tree->Branch("Thr","std::vector<int>",&fThr);
    _tree->Branch("difId","std::vector<int>",&fDifId);
    _tree->Branch("EvtNbr","std::vector<int>",&fNevt);
    _tree->Branch("EvtReconstructed","std::vector<int>",&fEvtReconstructed);
    _tree->Branch("PrevTime","std::vector<int>", &fPrevTime);
    _tree->Branch("Time","std::vector<int>", &fTime);
    _tree->Branch("TimePeak","std::vector<int>", &fTimePeak);
    _tree->Branch("PrevTimePeak","std::vector<int>", &fPrevTimePeak);
    _tree->Branch("DeltaTimePeak","std::vector<int>", &fDeltaTimePeak);
    _tree->Branch("TriggerNbr","std::vector<int>",&fTriggerNr);
    _tree->Branch("Nhit","std::vector<int>",&fNhit);
    _tree->Branch("CerenkovTag1","std::vector<int>",&fCerenkovTag1);
    _tree->Branch("CerenkovTag2","std::vector<int>",&fCerenkovTag2);
    _tree->Branch("CerenkovTag3","std::vector<int>",&fCerenkovTag3);
    _tree->Branch("CerenkovCount1","std::vector<int>",&fCerenkovCount1);
    _tree->Branch("CerenkovCount2","std::vector<int>",&fCerenkovCount2);
    _tree->Branch("CerenkovCount3","std::vector<int>",&fCerenkovCount3);
    _tree->Branch("CerenkovCountDecember","std::vector<int>",&fCerenkovCountDecember);

    // _tree->Branch("Pion","std::vector<int>",&fPion);
    // _tree->Branch("Electron","std::vector<int>",&fElectron);
    // _tree->Branch("Muon","std::vector<int>",&fMuon);
}

//==================================================================================
void Trivent::ClearVector()
{
    x.clear();
    y.clear();
    z.clear();
    fThr.clear();
    fDifId.clear();
    fNevt.clear();
    fEvtReconstructed.clear();
    fPrevTime.clear();
    fTime.clear();
    fTimePeak.clear();
    fPrevTimePeak.clear();
    fDeltaTimePeak.clear();
    fNhit.clear();
    fTriggerNr.clear();
    fCerenkovTag1.clear();
    fCerenkovTag2.clear();
    fCerenkovTag3.clear();
    fCerenkovCount1.clear();
    fCerenkovCount2.clear();
    fCerenkovCount3.clear();
    fCerenkovCountDecember.clear();

    //    fPion.clear();
    //    fElectron.clear();
    //    fMuon.clear();
}

void Trivent::fillTree()
{
    _file->cd();
    _tree->Fill();
}

//==================================================================================
//void Trivent::setTriggerRawHit() {

//}
//==================================================================================
void Trivent::processRunHeader( LCRunHeader * runHd ) {

}

//==================================================================================
void Trivent::processEvent( LCEvent * evtP ){

    ClearVector();
    if (evtP != NULL)
    {
        try
        {
            _eventNbr=evtP->getEventNumber();
            for(unsigned int i=0; i< _hcalCollections.size(); i++){//!loop over collection
                try
                {
                    LCCollection * col = NULL;
                    col = evtP ->getCollection(_hcalCollections[i].c_str());
                    int numElements = col->getNumberOfElements();// hit number
                    if ( m_trigCount==0 || (m_trigCount % 100) == 0)
                    {
                        streamlog_out( MESSAGE ) << "Selected Event so far: " << _selectedNum << std::endl;
                        streamlog_out( MESSAGE ) << yellow << "Trigger number == " << m_trigCount << normal << std::endl;
                    }
                    m_trigCount++;

                    if(col == NULL )  {
                        streamlog_out( WARNING )<< red << "TRIGGER SKIPED ...Col == NULL"<< normal <<std::endl;
                        break;
                    }

                    if(numElements > m_elecNoiseCut)  {
                        streamlog_out( DEBUG ) << red << "TRIGGER SKIPED ...NoiseCut"<< normal <<std::endl;
                        break;
                    }

                    // set raw hits
                    m_triggerRawHit.clear();
                    m_cerenkovHits.clear();
                    std::vector<int> vTrigger;

                    for (int ihit(0); ihit < col->getNumberOfElements(); ++ihit) // loop over the hits
                    {
                        RawCalorimeterHit *rawHit =
                                dynamic_cast<RawCalorimeterHit*>( col->getElementAt(ihit)) ;
                        if (NULL != rawHit)
                        {
                            unsigned int difid=0;
                            difid = rawHit->getCellID0()&0xFF;

                            //extract abolute bcid information:
                            if(ihit==0)
                            {
                                if (difid==0) continue;

                                std::stringstream pname("");
                                pname <<"DIF"<<difid<<"_Triggers";

                                col->getParameters().getIntVals(pname.str(),vTrigger);
                                if (vTrigger.size()!=0)
                                {
                                    _bcid1=vTrigger[4] ;
                                    _bcid2=vTrigger[3] ;
                                    unsigned long long Shift=16777216ULL;//to shift the value from the 24 first bits
                                    unsigned long long theBCID_=_bcid1*Shift+_bcid2;
                                    streamlog_out( DEBUG1 ) << "trigger time : " << theBCID_ << std::endl;
                                }
                            }

                            //                            // Shift the CTag to be around the Event Time
                            //                            if (difid == _cerenkovDifId) {
                            //                                streamlog_out( DEBUG ) << blue << "Hit: " << ihit << " Ca tape dans l'tcher!" << normal << std::endl;

                            //                                // Copy RawHit into a CerenkovHit
                            //                                IMPL::RawCalorimeterHitImpl *pCerenkRawHit = new IMPL::RawCalorimeterHitImpl;
                            //                                pCerenkRawHit->setAmplitude(rawHit->getAmplitude());
                            //                                pCerenkRawHit->setCellID0(rawHit->getCellID0());
                            //                                pCerenkRawHit->setCellID1(rawHit->getCellID1());
                            //                                pCerenkRawHit->setTimeStamp(rawHit->getTimeStamp() + _cerenkovOffset); // Shift CTag with delay added in the acquisition
                            //                                //                                _cerenkovHits.push_back(pCerenkRawHit);
                            //                                m_triggerRawHit.push_back(pCerenkRawHit);
                            //                                //                                delete pCerenkRawHit; pCerenkRawHit = NULL;

                            //                            }else
                            //                            {
                            //                                streamlog_out( MESSAGE ) << red << "Hit: " << ihit << " Ca tape pas dans l'tcher!" << normal << std::endl;
                            m_triggerRawHit.push_back(rawHit);
                            //                            }
                        }
                    }
                    getMaxTime();
                    std::vector<int> timeSpectrum = getTimeSpectrum();

                    //---------------------------------------------------------------
                    //! Find the candidate event
                    int ibin=0;
                    int bin_c_prev = -2 * m_timeWindow; //  the previous bin center

                    int time_prev = 0;
                    while(ibin < (m_maxTime+1)){
                        if(timeSpectrum[ibin] >= m_noiseCut &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin+1] &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin-1] &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin-2] &&
                                timeSpectrum[ibin] >= timeSpectrum[ibin+2] )
                        {
                            LCEventImpl*  evt = new LCEventImpl() ;     // create the event

                            //---------- set event paramters ------
                            const std::string parname_trigger = "trigger";
                            const std::string parname_energy  = "beamEnergy";
                            const std::string parname_bcid1 = "bcid1";
                            const std::string parname_bcid2 = "bcid2";
                            const std::string parname_cerenkov1 = "cerenkov1";
                            const std::string parname_cerenkov2 = "cerenkov2";
                            const std::string parname_cerenkov3 = "cerenkov3";

                            evt->parameters().setValue(parname_trigger,evtP->getEventNumber());
                            evt->parameters().setValue(parname_energy , m_beamEnergy);
                            evt->parameters().setValue(parname_bcid1 , _bcid1);
                            evt->parameters().setValue(parname_bcid2 , _bcid2);
                            evt->setRunNumber( evtP->getRunNumber()) ;

                            //-------------------------------------
                            LCCollectionVec* outcol = new LCCollectionVec(LCIO::CALORIMETERHIT);

                            m_evtNbr++;
                            _cerenkovCount[0] = _cerenkovCount[1] = _cerenkovCount[2] = 0;


                            Trivent::eventBuilder(outcol,ibin,bin_c_prev);
                            evt->parameters().setValue(parname_cerenkov1, _cerenkovCount[0]); // Value determined in the eventBuilder
                            evt->parameters().setValue(parname_cerenkov2, _cerenkovCount[1]); // Value determined in the eventBuilder
                            evt->parameters().setValue(parname_cerenkov3, _cerenkovCount[2]); // Value determined in the eventBuilder
                            // ->Need to be after the EventBuilder function

                            if( (int)_zCut.size() >m_layerCut &&                                  // the min layer numb cut
                                    abs(int(ibin)-time_prev) > m_time2PreviousEventCut)// time2prev event  cut
                            {

                                streamlog_out( DEBUG ) << "Evt number : " <<  m_evtNbr << std::endl;
                                streamlog_out( DEBUG ) <<green<<" Trivent find event at :==> "<< red << ibin
                                                      <<green<<"\t :Nhit: ==> "<< magenta
                                                     <<outcol->getNumberOfElements() << normal <<std::endl;
                                evt->setEventNumber( m_evtNbr ) ;
                                evt->addCollection(outcol, "SDHCAL_HIT");
                                _lcWriter->writeEvent( evt ) ;
                                evts.push_back(evt);
                                _selectedNum++;

                            }else
                            {
                                _rejectedNum++;
                                delete outcol; outcol = NULL;
                            }
                            time_prev = ibin;
                            delete evt; evt=NULL;
                            bin_c_prev = ibin;
                            ibin = ibin+m_timeWindow;
                        }else{ibin++;}
                    }
                    _tree->Fill();
                }catch (lcio::DataNotAvailableException zero) {}
            }
        }catch (lcio::DataNotAvailableException err) {}
    }


}
//==============================================================
void Trivent::end()
{
    streamlog_out( MESSAGE )<< "Trivent Rejected "<<_rejectedNum <<" Candidate event"<<std::endl;
    streamlog_out( MESSAGE )<< "Trivent Selected "<<_selectedNum <<" Candidate event"<<std::endl;
    streamlog_out( MESSAGE )<< "Trivent end"<<std::endl;
    streamlog_out( MESSAGE )<< "Total Cerenkov1 Tags: " << _cerenkovCountTotal[0] << std::endl;
    streamlog_out( MESSAGE )<< "Total Cerenkov2 Tags: " << _cerenkovCountTotal[1] << std::endl;
    streamlog_out( MESSAGE )<< "Total Cerenkov3 Tags: " << _cerenkovCountTotal[2] << std::endl;


    // cc.StoreHistos("test.root");
    _lcWriter->close();


    if (_tree) {
        TFile *_logroot = _tree->GetCurrentFile();
        _logroot->Write();
        delete _logroot;
    }
}
//bool Trivent::getCerenkov() const
//{
//    return _cerenkov1;
//}

//void Trivent::setCerenkov(bool cerenkov)
//{
//    _cerenkov1 = cerenkov;
//}

//==============================================================

void Trivent::setInputCollectionName(const std::string &inputCollectionName)
{
    m_inputCollectionName = inputCollectionName;
}

void Trivent::setOutputCollectionName(const std::string &outputCollectionName)
{
    m_outputCollectionName = outputCollectionName;
}

void Trivent::setOutputNoiseFileName(const std::string &noiseFileName)
{
    m_noiseFileName = noiseFileName;
}

void Trivent::setGeometryXMLFile(const std::string &geomXMLFile)
{
    m_geomXMLFile = geomXMLFile;
}

void Trivent::setLayerCut(const int &layerCut)
{
    m_layerCut = layerCut;
}

void Trivent::setNoiseCut(const int &noiseCut)
{
    m_noiseCut = noiseCut;
}

void Trivent::setTimeWindow(const int &timeWindow)
{
    m_timeWindow = timeWindow;
}

void Trivent::setLayerGap(const double &layerGap)
{
    m_layerGap = layerGap;
}

void Trivent::setElecNoiseCut(const int &elecNoiseCut)
{
    m_elecNoiseCut = elecNoiseCut;
}

void Trivent::setTime2PreviousEventCut(const int &time2PreviousEventCut)
{
    m_time2PreviousEventCut = time2PreviousEventCut;
}

void Trivent::setGainCorrectionMode(const bool gainCorrectionMode)
{
    m_gainCorrectionMode = gainCorrectionMode;
}

void Trivent::setCerenkovWindow(const int cerenkovWindow)
{
    m_cerenkovWindow = cerenkovWindow;
}

void Trivent::setCerenkovLength(const int cerenkovLength)
{
    m_cerenkovLength = cerenkovLength;
}

void Trivent::setCerenkovDifId(const int cerenkovDifId)
{
    m_cerenkovDifId = cerenkovDifId;
}


}
