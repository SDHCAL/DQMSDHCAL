/// \file NoiseAnalysisModule.cc
/*
 *
 * NoiseAnalysisModule.cc source template automatically generated by a class generator
 * Creation date : ven. aoï¿½t 28 2015
 *
 * This file is part of DQMSDHCAL libraries.
 *
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete, Arnaud Steen
 * @copyright CNRS , IPNL
 */

#include "NoiseAnalysisModule.h"

// -- dqmsdhcal headers
#include "ElectronicsMapping.h"

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMModuleApi.h"
// #include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMLogging.h"


// -- std headers
#include <iostream>
#include <fstream>
#include <math.h>

//-- lcio headers
#include <EVENT/LCCollection.h>
#include <EVENT/CalorimeterHit.h>
// #include <EVENT/MCParticle.h>
// #include <IMPL/RawCalorimeterHitImpl.h>
#include <IMPL/LCCollectionVec.h>
// #include <IMPL/LCFlagImpl.h>
// #include <IMPL/LCRelationImpl.h>
// #include <EVENT/LCParameters.h>
// #include <IMPL/LCTOOLS.h>
// #include <UTIL/CellIDDecoder.h>

using namespace dqm4hep;

namespace dqm_sdhcal
{
// plugin declaration
DQM_PLUGIN_DECL( NoiseAnalysisModule, "NoiseAnalysisModule" )

NoiseAnalysisModule::NoiseAnalysisModule() :
  DQMAnalysisModule(),
  m_cellReferencePosition(0.f, 0.f, 0.f),
  m_cellSize0(10.408f),
  m_cellSize1(10.408f)
{
}

//-------------------------------------------------------------------------------------------------
NoiseAnalysisModule::~NoiseAnalysisModule()
{
  for (std::vector< CaloHitCollectionConverter *>::iterator iter = m_dataConverters.begin(), endIter = m_dataConverters.end() ;
       endIter != iter ; ++iter)
    delete *iter;

  m_dataConverters.clear();
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::initModule()
{
  m_nEventProcessed = 0;
  m_hitTimeMin = 99999999.;
  m_hitTimeMax = 0;
  m_eventIntegratedTime = 0;
  m_spillIntegratedTime = 0;
  m_totalIntegratedTime = 0;
  m_timeLastTrigger = 0;
  m_timeLastSpill = 0;
  m_moduleLogStr = "[NoiseAnalysisModule]";
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
  /* ------ Detector Settings ------ */
  m_nActiveLayers = 48;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                   "NActiveLayers", m_nActiveLayers));

  m_nStartLayerShift = 0;
  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                          "NStartLayerShift", m_nStartLayerShift));

  m_nAsicPerDif = 48;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                   "NAsicPerDif", m_nAsicPerDif));

  m_nChanPerAsic = 64;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                   "NChanPerAsic", m_nChanPerAsic));
  /* ------ End Detector Settings ------ */


  // /*------------- Converter settings ------------*/
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
  "RawCollectionNames", m_rawCollectionNames, [] (const dqm4hep::StringVector & vec) { return ! vec.empty(); }));

  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
  "RecCollectionNames", m_recCollectionNames, [&] (const dqm4hep::StringVector & vec) { return vec.size() == m_rawCollectionNames.size(); }));

  dqm4hep::TiXmlElement *pConvXmlElement = xmlHandle.FirstChild("RawDataConverters").Element();

  if ( ! pConvXmlElement )
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Couldn't find xml element RawDataConverters !" );
    return dqm4hep::STATUS_CODE_NOT_FOUND;
  }
  dqm4hep::TiXmlHandle convertersHandle(pConvXmlElement);

  for (dqm4hep::TiXmlElement *pXmlElement = convertersHandle.FirstChild("converter").Element(); NULL != pXmlElement;
       pXmlElement = pXmlElement->NextSiblingElement("converter"))
  {
    if ( m_dataConverters.size() == m_rawCollectionNames.size() )
    {
      LOG4CXX_WARN( dqm4hep::dqmMainLogger, m_moduleLogStr << " - Warning additional raw data converter plugin loading will be skipped !" );
      break;
    }

    std::string plugin;
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::getAttribute(pXmlElement, "plugin", plugin));

    CaloHitCollectionConverter *pConverter = dqm4hep::DQMPluginManager::instance()->createPluginClass<CaloHitCollectionConverter>(plugin);

    if ( NULL == pConverter )
    {
      LOG4CXX_WARN( dqm4hep::dqmMainLogger, m_moduleLogStr << " - pConverter is NULL!" );
      return dqm4hep::STATUS_CODE_NOT_FOUND;
    }

    dqm4hep::TiXmlHandle converterHandle(pXmlElement);
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, pConverter->readSettings(converterHandle));

    m_dataConverters.push_back( pConverter );
  }

  if ( m_dataConverters.size() != m_rawCollectionNames.size() )
    return dqm4hep::STATUS_CODE_INVALID_PARAMETER;
  /*---------------------------------------------------*/


  /*------------- Read electronics Mapping settings ------------*/
  // Needed to access dif/asic/chan informations
  // TODO Make a vec of electronicsMapping for different collections
  TiXmlElement *pElecMapElement = xmlHandle.FirstChild("electronicsMapping").Element();

  if ( ! pElecMapElement )
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << "Couldn't find xml element electronicsMapping !" );
    return dqm4hep::STATUS_CODE_NOT_FOUND;
  }

  std::string plugin;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::getAttribute(pElecMapElement, "plugin", plugin));

  m_pElectronicsMapping = dqm4hep::DQMPluginManager::instance()->createPluginClass<dqm4hep::DQMElectronicsMapping>(plugin);

  if ( ! m_pElectronicsMapping )
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << "Couldn't find electronicsMapping plugin called : " << plugin );
    return dqm4hep::STATUS_CODE_NOT_FOUND;
  }

  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->readSettings(dqm4hep::TiXmlHandle(pElecMapElement)));
  /*------------- End Electronics Mapping settings ------------*/


  /*------------- Read Geometry Mapping settings ------------*/
  // Needed here only for Geometry dependent Histogram booking (Know dif/layer association)
  // No need for a DB access here as the geometry was already read from the DB/xml in the electronicsMapping settings
  // Then written to a xml file
  // Just need to ensure the same files are used in the xml settings !!!
  bool readFromDB = false;
  dqm4hep::TiXmlHandle electronicsXmlHandle = dqm4hep::TiXmlHandle(pElecMapElement);

  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(electronicsXmlHandle,
                          "ReadFromDB", readFromDB));


  std::string geometryFileName = "geometry_SPS_08_2012.xml";
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(electronicsXmlHandle,
                   "GeometryFileName", geometryFileName));

  if ( readFromDB )
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << "Read from DataBase is deactivated here. Geometry should have already been loaded from the dataConverter, please use the same xmlFil. " );
  }

  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(electronicsXmlHandle,
                          "CellReferencePosition", m_cellReferencePosition));
  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(electronicsXmlHandle,
                          "CellSize0", m_cellSize0));
  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(electronicsXmlHandle,
                          "CellSize1", m_cellSize1));
  dqm4hep::UIntVector layerMask;
  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(electronicsXmlHandle,
                          "LayerMask", layerMask));
  dqm4hep::UIntVector difMask;
  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(electronicsXmlHandle,
                          "DifMask", difMask));

  GeometryXmlIO reader;
  RETURN_RESULT_IF( dqm4hep::STATUS_CODE_SUCCESS, !=, reader.load( geometryFileName , m_geometry, layerMask , difMask ) );

  for (Geometry::const_iterator iter = m_geometry.begin(), endIter = m_geometry.end() ;
       endIter != iter ; ++iter)
    for (DifMapping::const_iterator difIter = iter->second.m_difList.begin(), difEndIter = iter->second.m_difList.end() ;
         difEndIter != difIter ; ++difIter)
      m_difMapping[ difIter->first ] = difIter->second;
  /*------------- End Geometry Mapping settings ------------*/


  /* ------ Booking Monitor Elements ------ */
  // ------ General ME ------
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TimeDiffSpill", m_pTimeDiffSpill));
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TimeDiffTriggerToSpill", m_pTimeDiffTriggerToSpill));
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "SpillLength", m_pSpillLength));

  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicOccupancyAll", m_pAsicOccupancyAll));
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicOccupancyChamber", m_pAsicOccupancyChamber));
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicOccupancyDIF", m_pAsicOccupancyDIF));

  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AcquisitionTime", m_pAcquisitionTime));
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "HitFrequencyMap", m_pHitFrequencyMap));

  // ------ PerLayer ME ------
  for (DifMapping::iterator difIter = m_difMapping.begin(), difEndIter = m_difMapping.end() ;
       difEndIter != difIter ; ++difIter)
  {
    int difId = difIter->first;
    int layerId = difIter->second.m_layerId + m_nStartLayerShift;
    std::string folderPath = "/Noise/Layer" + std::to_string(layerId);

    // TODO: Get rid of the [ERROR] - pDirectory->findDir(dirName, pDirectory) return STATUS_CODE_NOT_FOUND
    //                      [ERROR] -     in function: cd
    if (dqm4hep::STATUS_CODE_NOT_FOUND == dqm4hep::DQMModuleApi::cd(this, folderPath))
    {
      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::mkdir(this, folderPath));
      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::cd(this, folderPath));

      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ChamberHitsMap1", m_layerElementMap[layerId].m_pChamberHitsMap1));
      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ChamberHitsMap2", m_layerElementMap[layerId].m_pChamberHitsMap2));
      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "ChamberHitsMap3", m_layerElementMap[layerId].m_pChamberHitsMap3));
    }

    // ------ PerDIF ME ------
    folderPath += "/DIF" + std::to_string(difId) + "/";
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::mkdir(this, folderPath));
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::cd(this, folderPath));

    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicOccupancy", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicOccupancy));
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicOccupancyNumber", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicOccupancyNumber));

    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicHits1", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicHits1));
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicHits2", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicHits2));
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicHits3", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicHits3));

    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicFrequency1", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicFreq1));
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicFrequency2", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicFreq2));
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicFrequency3", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicFreq3));

    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicEventTime", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicEventTime));
    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle, "AsicEventTimeZoom", m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicEventTimeZoom));
  }
  /* ------ End Booking Monitor Elements ------ */
  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Finished booking ME ");


  // Print Monitor Elements tree structure
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::cd(this, "/"));
  dqm4hep::DQMModuleApi::ls(this, true);

  /* ------ Analysis Settings ------ */
  m_inputCollectionName = "SDHCAL_HIT";
  RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                          "InputCollectionName", m_inputCollectionName));

  m_newSpillTimeCut = 10;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                   "SpillLength", m_newSpillTimeCut));

  m_DAQ_BC_Period = 200; // Size of a clock frame, in nsecond
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                   "ClockFrameLength", m_DAQ_BC_Period));
  m_DAQ_BC_Period *= 1E-9; // Size of a clock frame, in second

  m_skipEvent = 0; //=1 to skip first event of the aquisition
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                   "NumberOfEventToSkip", m_skipEvent));

  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::decodeTrigger( EVENT::LCCollection *  const pCalorimeterHitCollection, caloobject::CaloHit * const pWrapperHit)
{
  dqm4hep::DQMCartesianVector position(
    pWrapperHit->getPosition().x(),
    pWrapperHit->getPosition().y(),
    pWrapperHit->getPosition().z()
  );

  dqm4hep::DQMElectronicsMapping::Electronics electronics;
  dqm4hep::DQMElectronicsMapping::Cell cell;

  if (dqm4hep::STATUS_CODE_SUCCESS != m_pElectronicsMapping->positionToCell(position, cell))
    LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - positionToCell Failed! ");
  if (dqm4hep::STATUS_CODE_SUCCESS != m_pElectronicsMapping->cellToElectronics(cell, electronics))
    LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - cellToElectronics Failed! ");

  unsigned int difId = electronics.m_difId;

  // Find Trigger information & Extract abolute bcid
  std::vector<int> vTrigger;
  std::stringstream pname("");
  pname << "DIF" << difId << "_Triggers";

  pCalorimeterHitCollection->getParameters().getIntVals(pname.str(), vTrigger);

  if (vTrigger.size() != 0)
  {
    dqm4hep::dqm_uint m_bcid1 = vTrigger[4];
    dqm4hep::dqm_uint m_bcid2 = vTrigger[3];

    // Shift the value from the 24 first bits
    unsigned long long Shift = 16777216ULL;
    unsigned long long theBCID_ = m_bcid1 * Shift + m_bcid2;
    double timeTrigger = theBCID_ * m_DAQ_BC_Period; // in seconds since start of run
    double timeDif = timeTrigger - m_timeLastTrigger;

    if (timeDif != 0)
    {
      LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - New Trigger at time : " << theBCID_ << " - time since previous trigger : " << timeDif << "s");
    }

    if (timeDif > m_newSpillTimeCut) // New Spill
    {
      LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - New Spill -  time since last spill : " <<  timeTrigger - m_timeLastSpill << " s. Length of spill : " << m_spillIntegratedTime * m_DAQ_BC_Period << "\t " << m_nParticleLastSpill << " particles in last spill" );
      m_nParticleLastSpill = 0;
      m_spillIntegratedTime = 0;

      m_pSpillLength->get<TH1>()->Fill(m_spillIntegratedTime * m_DAQ_BC_Period);
      m_pTimeDiffTriggerToSpill->get<TH1>()->Fill(timeDif);
      m_pTimeDiffSpill->get<TH1>()->Fill(timeTrigger - m_timeLastSpill);
      // TODO: Make a TGraph of TotalHitPerSpill vs Time -> Quickly see time since last spill
      //       Float timeTrigger - m_timeLastSpill
      m_timeLastSpill = timeTrigger;
    }
    m_timeLastTrigger = timeTrigger;
  }
  return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::performOutputDataConversion(EVENT::LCEvent *pLCEvent)
{
  const unsigned int nCollections(m_rawCollectionNames.size());

  for (unsigned int c = 0 ; c < nCollections ; c++)
  {
    const std::string rawCollectionName( m_rawCollectionNames.at(c) );
    const std::string recCollectionName( m_recCollectionNames.at(c) );
    CaloHitCollectionConverter *pDataConverter( m_dataConverters.at(c) );

    try
    {
      EVENT::LCCollection *pLCCollection = pLCEvent->getCollection( rawCollectionName );
      IMPL::LCCollectionVec *pRecCollection = new IMPL::LCCollectionVec(EVENT::LCIO::CALORIMETERHIT);

      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, pDataConverter->convert(pLCCollection, pRecCollection));

      pLCEvent->addCollection( pRecCollection , recCollectionName );
    }
    catch (EVENT::DataNotAvailableException &exception)
    {
      LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
      continue;
    }
  }
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::processEvent(dqm4hep::DQMEvent * const pEvent)
{
  EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

  if (NULL == pLCEvent)
  {
    LOG4CXX_WARN( dqm4hep::dqmMainLogger , m_moduleLogStr << " - pLCEvent is NULL! ");
    return dqm4hep::STATUS_CODE_FAILURE;
  }

  if (pLCEvent->getEventNumber() <= m_skipEvent)
  {
    LOG4CXX_WARN( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Skipping Trigger Event " << pLCEvent->getEventNumber() << " ... skipEvent parameter: " << m_skipEvent );
    return dqm4hep::STATUS_CODE_SUCCESS;
  }

  LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Processing Trigger event no " << pLCEvent->getEventNumber() << " runNumber no " << pLCEvent->getRunNumber() << " ..." );
  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Time Stamp: " << pLCEvent->getTimeStamp() );

  // Convert DHCALRawHits to SDHCAL_HIT
  THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->performOutputDataConversion(pLCEvent));

  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Available Collection in event : ");
  for (std::vector<std::string>::const_iterator iter = pLCEvent->getCollectionNames()->begin(), endIter = pLCEvent->getCollectionNames()->end() ;
       endIter != iter ; ++iter)
    LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr <<  "\t\t " << (*iter)  );


  CLHEP::Hep3Vector globalHitShift(0, 0, 0);
  m_eventIntegratedTime = 0;
  m_hitTimeMin = 99999999.;
  m_hitTimeMax = 0;
  m_asicMap.clear();

  try
  {
    EVENT::LCCollection *pCalorimeterHitCollection = pLCEvent->getCollection(m_inputCollectionName);
    LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " Created collection with type : " << pCalorimeterHitCollection->getTypeName());
    LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " NumberOfHits in trigger : " << pCalorimeterHitCollection->getNumberOfElements() );

    if (NULL == pCalorimeterHitCollection)
    {
      LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " NULL Pointer: pCalorimeterHitCollection pointer " );
      return dqm4hep::STATUS_CODE_SUCCESS;
    }

    // Loop over hits in this event & Fill the rawCaloHitCollection
    for (unsigned int h = 0 ; h < pCalorimeterHitCollection->getNumberOfElements() ; ++h)
    {
      EVENT::CalorimeterHit *pRawCaloHit = dynamic_cast<EVENT::CalorimeterHit*>(pCalorimeterHitCollection->getElementAt(h));
      if (NULL == pRawCaloHit)
        continue;

      /* --- Create pWrapperHits and get chan/asic/dif/layer infos about the hit --- */
      // Position information for pWrapperHit
      CLHEP::Hep3Vector positionVector(
        pRawCaloHit->getPosition()[0],
        pRawCaloHit->getPosition()[1],
        pRawCaloHit->getPosition()[2] );

      // Position informatino for cell/electronics
      dqm4hep::DQMCartesianVector position(
        pRawCaloHit->getPosition()[0],
        pRawCaloHit->getPosition()[1],
        pRawCaloHit->getPosition()[2]
      );

      dqm4hep::DQMElectronicsMapping::Electronics electronics;
      dqm4hep::DQMElectronicsMapping::Cell cell;

      if (dqm4hep::STATUS_CODE_SUCCESS != m_pElectronicsMapping->positionToCell(position, cell))
      {
        LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - positionToCell Failed! ");
        continue;
      }

      if (dqm4hep::STATUS_CODE_SUCCESS != m_pElectronicsMapping->cellToElectronics(cell, electronics))
      {
        LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - cellToElectronics Failed! ");
        continue;
      }

      unsigned int difId = electronics.m_difId;
      unsigned int asicId = electronics.m_asicId;
      unsigned int chanId = electronics.m_channelId;

      int cellID[3];
      cellID[0] = cell.m_iCell;
      cellID[1] = cell.m_jCell;
      cellID[2] = cell.m_layer;

      if ( cell.m_layer >= m_nActiveLayers )
      {
        LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong number of layer in your configuration file!");
        LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Found a hit in layer " << cell.m_layer << " - Last layer in xml configuration file is " << m_nActiveLayers);
        continue;
      }
      unsigned int hitTime = pRawCaloHit->getTime();
      unsigned int hitThresh = pRawCaloHit->getEnergy();

      caloobject::CaloHit *pWrapperHit = new caloobject::CaloHit(
        cellID,
        positionVector,
        hitThresh,
        hitTime,
        globalHitShift);

      //Find Triggers and NewSpill
      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, decodeTrigger(pCalorimeterHitCollection, pWrapperHit));

      // RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, doDIFStudy(pRawCaloHit));

      if ( hitTime * m_DAQ_BC_Period > 1. ) // hits after 1s ?!
      {
        LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - \t\t\t T'as vu l'heure?!!! : " << hitTime);
        LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Amplitude: " << hitThresh
                      << "\t Layer : " << cell.m_layer
                      << "\t dif : " << difId
                      << "\t asic : " << asicId
                      << "\t chan : " << chanId
                      << "\t I : " << cell.m_iCell
                      << "\t J : " << cell.m_jCell
                      << "\t time : " << hitTime
                      << "\t time (s): " << hitTime * m_DAQ_BC_Period
                    );
        // some hits have a time stamp of 4294967295 = 858.993s ??? ->Cerenkov?
        continue;
      }

      if (hitTime < m_hitTimeMin) m_hitTimeMin = hitTime;
      if (hitTime > m_hitTimeMax) m_hitTimeMax = hitTime;
      m_eventIntegratedTime = (m_hitTimeMax - m_hitTimeMin); // TODO Moronic calculation here !

      if (hitThresh <= 0 || hitThresh > 3)
      {
        LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << difId << " had:" << asicId << ":" << chanId << ":" << hitTime << ":" << hitThresh);
        continue;
      }
      bool thr[3];

      thr[0] = (hitThresh == 2);  // First Threshold
      thr[1] = (hitThresh == 1);  // Second Threshold
      thr[2] = (hitThresh == 3);  // Third Threshold

      // ---------- Fill /Layer/DIF
      TH1* h_asicHit1 = m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicHits1->get<TH1>();
      TH1* h_asicHit2 = m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicHits2->get<TH1>();
      TH1* h_asicHit3 = m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicHits3->get<TH1>();
      TH1* h_asicFreq1 = m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicFreq1->get<TH1>();
      TH1* h_asicFreq2 = m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicFreq2->get<TH1>();
      TH1* h_asicFreq3 = m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicFreq3->get<TH1>();

      if (thr[0] || thr[1] || thr[2])
      {
        h_asicHit1->SetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1, h_asicHit1->GetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1) + 1);
        h_asicFreq1->SetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1, h_asicHit1->GetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1) / m_eventIntegratedTime);
        m_layerElementMap[cell.m_layer].m_pChamberHitsMap1->get<TH2>()->Fill(cell.m_iCell, cell.m_jCell);
        m_pHitFrequencyMap->get<TH2>()->SetBinContent(difId + 1, asicId, m_pHitFrequencyMap->get<TH2>()->GetBinContent(difId + 1, asicId) + 1);
      }
      if (thr[1] || thr[2])
      {
        h_asicHit2->SetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1, h_asicHit2->GetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1) + 1);
        h_asicFreq2->SetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1, h_asicHit2->GetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1) / m_eventIntegratedTime);
        m_layerElementMap[cell.m_layer].m_pChamberHitsMap2->get<TH2S>()->Fill(cell.m_iCell, cell.m_jCell);
      }
      if (thr[2])
      {
        h_asicHit3->SetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1, h_asicHit3->GetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1) + 1);
        h_asicFreq3->SetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1, h_asicHit3->GetBinContent((asicId - 1) * m_nChanPerAsic + chanId + 1) / m_eventIntegratedTime);
        m_layerElementMap[cell.m_layer].m_pChamberHitsMap3->get<TH2>()->Fill(cell.m_iCell, cell.m_jCell);
      }

      m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicEventTime->get<TH1>()->Fill(hitTime);
      m_layerElementMap[cell.m_layer].m_difElementMap[difId].m_pAsicEventTimeZoom->get<TH1>()->Fill(hitTime);

      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, fillAsicOccupancyMap(pWrapperHit));
    }
    m_spillIntegratedTime += m_eventIntegratedTime; // TODO: not right
    m_totalIntegratedTime += m_eventIntegratedTime; // TODO: not right

    LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " m_hitTimeMin : " << m_hitTimeMin << "\t m_hitTimeMax : " << m_hitTimeMax << "\t eventIntegratedTime : " << m_eventIntegratedTime * m_DAQ_BC_Period << "s\t spillIntegratedTime : " << m_spillIntegratedTime * m_DAQ_BC_Period << "s\t totalIntegratedTime : " << m_totalIntegratedTime * m_DAQ_BC_Period << "s");

    RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, doAsicStudy());

    m_pAcquisitionTime->get<TH1F>()->Fill((m_eventIntegratedTime * m_DAQ_BC_Period));

    // Analyse rawCaloHits
    //
    // RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, doDIFStudy(pCalorimeterHitCollection));
    // RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, doAsicStudy(pCalorimeterHitCollection));
    // RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, doNoiseStudy(pCalorimeterHitCollection));
  }
  catch (EVENT::DataNotAvailableException &exception)
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Caught EVENT::DataNotAvailableException : " << exception.what() );
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Skipping event" );
    return STATUS_CODE_SUCCESS;
  }
  catch (...)
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " Caught unknown exception !");
    return STATUS_CODE_FAILURE;
  }
  m_nEventProcessed++;
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
int NoiseAnalysisModule::createAsicKey(int layerId, int difId, int asicId)
{
  return (layerId << 16) | (difId << 8) | asicId;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::fillAsicOccupancyMap( caloobject::CaloHit * const pWrapperHit)
{
  dqm4hep::DQMCartesianVector position(
    pWrapperHit->getPosition().x(),
    pWrapperHit->getPosition().y(),
    pWrapperHit->getPosition().z()
  );

  dqm4hep::DQMElectronicsMapping::Electronics electronics;
  dqm4hep::DQMElectronicsMapping::Cell cell;

  // Should not failed as it was already successful in processEvent
  if (dqm4hep::STATUS_CODE_SUCCESS != m_pElectronicsMapping->positionToCell(position, cell))
    LOG4CXX_FATAL( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - positionToCell Failed! ");
  if (dqm4hep::STATUS_CODE_SUCCESS != m_pElectronicsMapping->cellToElectronics(cell, electronics))
    LOG4CXX_FATAL( dqm4hep::dqmMainLogger , m_moduleLogStr <<  " - cellToElectronics Failed! ");

  unsigned int difId = electronics.m_difId;
  unsigned int asicId = electronics.m_asicId;

  DifMapping::const_iterator findDifIter = m_difMapping.find(difId);
  int layerId = findDifIter->second.m_layerId;

  int asicKey = createAsicKey(layerId, difId, asicId);

  std::map<int, int>::iterator findAsicIter = m_asicMap.find(asicKey);
  if (m_asicMap.find(asicKey) != m_asicMap.end())
    findAsicIter->second = findAsicIter->second + 1;
  else
  {
    int n = 1;
    std::pair<int, int> p(asicKey, n);
    m_asicMap.insert(p);
  }
  return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::doAsicStudy()
{
  for (std::map<int, int>::iterator asicIter = m_asicMap.begin(); asicIter != m_asicMap.end(); asicIter++)
  {
    unsigned int layerId = (asicIter->first >> 16) & 0xFF;
    unsigned int difId = (asicIter->first >> 8) & 0xFF;
    unsigned int asicId = (asicIter->first) & 0xFF;

    TH1F* hAsicOccupancyDIF = m_pAsicOccupancyDIF->get<TH1F>();
    TH1F* hAsicOccupancyChamber = m_pAsicOccupancyChamber->get<TH1F>();

    m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicOccupancyNumber->get<TH1F>()->SetBinContent(asicId, asicIter->second);
    m_layerElementMap[layerId].m_difElementMap[difId].m_pAsicOccupancy->get<TH1F>()->SetBinContent(asicId, asicIter->second / (m_eventIntegratedTime * m_DAQ_BC_Period));

    m_pAsicOccupancyAll->get<TH1F>()->SetBinContent(difId * m_nAsicPerDif + asicId, asicIter->second / (m_eventIntegratedTime * m_DAQ_BC_Period));
    float fOccupancy = asicIter->second / (m_eventIntegratedTime * m_DAQ_BC_Period);

    if (fOccupancy > hAsicOccupancyChamber->GetBinContent(layerId)) hAsicOccupancyChamber->SetBinContent(layerId, fOccupancy);
    if (fOccupancy > hAsicOccupancyDIF->GetBinContent(difId)) hAsicOccupancyDIF->SetBinContent(difId, fOccupancy);
  }
  return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode NoiseAnalysisModule::startOfCycle()
{
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode NoiseAnalysisModule::endOfCycle()
{
  // TODO Write to archive before resetting elements
  // this->resetElements();
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode NoiseAnalysisModule::startOfRun(dqm4hep::DQMRun * const pRun)
{
  m_totalIntegratedTime = 0;
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode NoiseAnalysisModule::endOfRun(dqm4hep::DQMRun * const pRun)
{
  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " Run lasted " << m_totalIntegratedTime << "s : " << floor(m_totalIntegratedTime / 3600) << "h " << floor(fmod(m_totalIntegratedTime / 60, 60)) << "min " << fmod(m_totalIntegratedTime, 60) <<  "s");
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode NoiseAnalysisModule::endModule()
{
  return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
void NoiseAnalysisModule::resetElements()
{
  for (std::map<unsigned int, LayerElements>::const_iterator iter = m_layerElementMap.begin(), endIter = m_layerElementMap.end() ;
       endIter != iter ; ++iter)
  {
    iter->second.m_pChamberHitsMap1->reset();
    iter->second.m_pChamberHitsMap2->reset();
    iter->second.m_pChamberHitsMap3->reset();

    for (std::map<int, DifElements>::const_iterator difIter = iter->second.m_difElementMap.begin(), difEndIter = iter->second.m_difElementMap.end() ;
         difEndIter != difIter ; ++difIter)
    {
      difIter->second.m_pAsicHits1->reset();
      difIter->second.m_pAsicHits2->reset();
      difIter->second.m_pAsicHits3->reset();

      difIter->second.m_pAsicFreq1->reset();
      difIter->second.m_pAsicFreq2->reset();
      difIter->second.m_pAsicFreq3->reset();

      difIter->second.m_pAsicOccupancy->reset();
      difIter->second.m_pAsicOccupancyNumber->reset();

      difIter->second.m_pAsicEventTime->reset();
      difIter->second.m_pAsicEventTimeZoom->reset();

    }
  }

  m_pTimeDiffSpill->reset();
  m_pTimeDiffTriggerToSpill->reset();
  m_pSpillLength->reset();
  m_pAcquisitionTime->reset();
  m_pAsicOccupancyAll->reset();
  m_pAsicOccupancyChamber->reset();
  m_pAsicOccupancyDIF->reset();
  m_pAcquisitionTime->reset();
  m_pHitFrequencyMap->reset();
}

}
