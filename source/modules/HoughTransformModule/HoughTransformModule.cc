/*
 *
 * HoughTransformModule.cc source template automatically generated by a class generator
 * Creation date : jeu. mars 10 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "HoughTransformModule.h"

#include "CaloObject/CaloHit.h"
#include "CaloObject/CaloCluster.h"
#include "CaloObject/CaloTrack.h"
#include "Algorithm/Tracking.h"
#include "Algorithm/ClusteringHelper.h"
#include "Algorithm/Cluster.h"
#include "Algorithm/Hough.h"

//-- lcio headers
#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>
#include <IMPL/CalorimeterHitImpl.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCFlagImpl.h>
#include <IMPL/LCRelationImpl.h>
#include <EVENT/LCParameters.h>
#include <UTIL/CellIDDecoder.h>

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"

#include <algorithm>

namespace dqm_sdhcal
{

DQM_PLUGIN_DECL( HoughTransformModule , "HoughTransformModule" )

//-------------------------------------------------------------------------------------------------

		HoughTransformModule::HoughTransformModule() :
		DQMTriventModule()
{

}

//-------------------------------------------------------------------------------------------------

HoughTransformModule::~HoughTransformModule()
{

}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::userInitModule()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::userReadSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_inputCollectionName = "SDHCAL_HIT";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"InputCollectionName", m_inputCollectionName));

	m_pNRecTracks = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"NRecTracks", m_pNRecTracks));

	m_pTrackChi2 = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"TrackChi2", m_pTrackChi2));

	m_pTrackLength = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"TrackLength", m_pTrackLength));

	m_pClusterSize = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"ClusterSize", m_pClusterSize));

	m_pThetaTrack = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"ThetaTrack", m_pThetaTrack));

	m_pPhiTrack = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"PhiTrack", m_pPhiTrack));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::processEvent(EVENT::LCEvent *pLCEvent)
{
	LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Processing physics event no " << pLCEvent->getEventNumber() );

	try
	{
		EVENT::LCCollection *pCalorimeterHitCollection = pLCEvent->getCollection(m_inputCollectionName);
		UTIL::CellIDDecoder<EVENT::CalorimeterHit> cellIDDecoder(pCalorimeterHitCollection);

		std::vector<caloobject::CaloHit*> caloHitList;
		std::map<unsigned int, std::vector<caloobject::CaloHit*> > caloHitMap;

		CLHEP::Hep3Vector globalHitShift(0, 0, 0);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Creating wrapper hits");

		// loop over hits in this event
		for(unsigned int h=0 ; h<pCalorimeterHitCollection->getNumberOfElements() ; h++)
		{
			EVENT::CalorimeterHit *pCaloHit = dynamic_cast<EVENT::CalorimeterHit*>(pCalorimeterHitCollection->getElementAt(h));

			if(NULL == pCaloHit)
				continue;

			int cellID[3];
			cellID[0] = cellIDDecoder(pCaloHit)["I"];
			cellID[1] = cellIDDecoder(pCaloHit)["J"];
			cellID[2] = cellIDDecoder(pCaloHit)["K-1"];

			CLHEP::Hep3Vector positionVector(
					pCaloHit->getPosition()[0],
					pCaloHit->getPosition()[1],
					pCaloHit->getPosition()[2] );

			caloobject::CaloHit *pWrapperHit = new caloobject::CaloHit(
					cellID,
					positionVector,
					pCaloHit->getEnergy(),
					pCaloHit->getTime(),
					globalHitShift);

			caloHitMap[ cellID[2] ].push_back(pWrapperHit);
			caloHitList.push_back( pWrapperHit );
		}

		// algorithms
		algorithm::Cluster clusteringAlgorithm;

		algorithm::ClusteringHelper clusteringHelper;
		algorithm::ClusteringHelperParameterSetting helperSettings;
		clusteringHelper.SetClusteringHelperParameterSetting(helperSettings);

		algorithm::Hough houghTransform;
		algorithm::HoughParameterSetting houghTransformSettings;
		houghTransform.SetHoughParameterSetting(houghTransformSettings);

		algorithm::Tracking trackingAlgorithm;
		algorithm::TrackingParameterSetting trackingParameters;
		trackingAlgorithm.SetTrackingParameterSetting(trackingParameters);


		// contents
		std::vector<caloobject::CaloCluster2D *> clusters;
		std::vector<caloobject::CaloTrack *>   tracks;

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Creating intra layer clusters");

		for(std::map<unsigned int, std::vector<caloobject::CaloHit*> >::iterator iter = caloHitMap.begin(), endIter = caloHitMap.end() ;
				iter != endIter ; ++iter)
			clusteringAlgorithm.Run(iter->second, clusters);

		std::sort(clusters.begin(), clusters.end(), algorithm::ClusteringHelper::SortClusterByLayer);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Filter non - isolated clusters");

		std::vector<caloobject::CaloCluster2D*> houghClusters;

		for(std::vector<caloobject::CaloCluster2D*>::iterator iter = clusters.begin(), endIter = clusters.end() ;
				endIter != iter ; ++iter)
			if( ! clusteringHelper.IsIsolatedCluster(*iter, clusters) )
				houghClusters.push_back(*iter);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Processing Hough transform");
		houghTransform.runHough(clusters, tracks, &trackingAlgorithm);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Analyzing tracks");
		THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->analyzeTracks(tracks));

		std::for_each(caloHitList.begin(), caloHitList.end(), [](caloobject::CaloHit *pCaloHit) { delete pCaloHit; });
		std::for_each(clusters.begin(), clusters.end(), [](caloobject::CaloCluster2D *pCluster) { delete pCluster; });
		std::for_each(tracks.begin(), tracks.end(), [](caloobject::CaloTrack *pTrack) { delete pTrack; });
	}
	catch(EVENT::DataNotAvailableException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
		return dqm4hep::STATUS_CODE_SUCCESS;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::analyzeTracks( const std::vector<caloobject::CaloTrack*> &tracks )
{
	if( tracks.empty() )
		return dqm4hep::STATUS_CODE_SUCCESS;

	const unsigned int nTracks = tracks.size();

	for(std::vector<caloobject::CaloTrack*>::const_iterator iter = tracks.begin(), endIter = tracks.end() ;
			endIter != iter ; ++iter)
	{
		caloobject::CaloTrack *pTrack = *iter;

		const std::vector<caloobject::CaloCluster2D*> &trackClusters(pTrack->getClusters());
		const unsigned int nClusters(trackClusters.size());

		const int startingLayer(pTrack->getTrackStartingCluster()->getLayerID());
		const int endingLayer(pTrack->getTrackLastCluster()->getLayerID());
		const int trackLenght(endingLayer - startingLayer);

		const float chi2(pTrack->getChi2());

		float meanClusterSize(0.f);

		std::for_each(trackClusters.begin(), trackClusters.end(),
				[&] (caloobject::CaloCluster2D *pCluster) {
			meanClusterSize += static_cast<float>(pCluster->getHits().size());
		});

		meanClusterSize /= static_cast<float>(nClusters);

		const std::vector<float> trackParameters = pTrack->getTrackParameters();

		const CLHEP::Hep3Vector trackPoint1( -1, 0, trackParameters[0] );
		const CLHEP::Hep3Vector trackPoint2( 0, -1, trackParameters[3] );
		const CLHEP::Hep3Vector trackDirection( trackPoint1.cross(trackPoint2).unit() );

		const float theta(trackDirection.theta());
		const float phi(trackDirection.phi());

		// fill monitor elements !
		m_pTrackLength->get<TH1>()->Fill(trackLenght);
		m_pTrackChi2->get<TH1>()->Fill(chi2);
		m_pClusterSize->get<TH1>()->Fill(meanClusterSize);
		m_pThetaTrack->get<TH1>()->Fill(theta);
		m_pPhiTrack->get<TH1>()->Fill(phi);
	}

	m_pNRecTracks->get<TH1>()->Fill(nTracks);

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::startOfCycle()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::endOfCycle()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::startOfRun(dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::endOfRun(dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::endModule()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

} 

