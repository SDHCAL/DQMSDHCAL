  /// \file Geometry.cc
/*
 *
 * Geometry.cc source template automatically generated by a class generator
 * Creation date : lun. avr. 11 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "Geometry.h"

// -- dqm4hep headers
#include "dqm4hep/DQMXmlHelper.h"

// -- std headers
#include <cstdio>
#include <algorithm>

namespace dqm_sdhcal
{

GeometryDBInterface::GeometryDBInterface() :
		dqm4hep::DQMDBInterface()
{

}

//-------------------------------------------------------------------------------------------------

GeometryDBInterface::~GeometryDBInterface()
{

}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode GeometryDBInterface::queryGeometry(const std::string &testName, std::map<unsigned int, ChamberGeometry> &geometry,
		const dqm4hep::UIntVector &layerMask, const dqm4hep::UIntVector &difMask)
{
	if( ! this->isConnected() )
		return dqm4hep::STATUS_CODE_NOT_INITIALIZED;

	int versionId = 0;

	std::stringstream query;
	query << "SELECT IDX FROM VERSIONS WHERE TESTNAME=\"" << testName << "\";";

	std::vector<int> versions;
	this->queryVector(query .str(), versions);

	// get last version
	if( ! versions.empty() )
		versionId = *versions.rbegin();

	query.str("");
	query << "select NUM,X0,Y0,Z0,X1,Y1,Z1,(SELECT NUM FROM PLANS WHERE PLANS.IDX=CHAMBERS.PLANID) FROM CHAMBERS WHERE (SELECT NUM FROM PLANS WHERE PLANS.IDX=CHAMBERS.PLANID) IS NOT NULL AND VERSIONID=" << versionId << ";";

	// query chamber list
	this->queryAndHandle(query.str(), [&] (MYSQL_RES *pMySQLResult)
	{
		MYSQL_ROW row;

		while( (row = mysql_fetch_row(pMySQLResult)) )
		{
			ChamberGeometry chamber;

			chamber.m_layerId = atoi( row[0] );

			if( std::find( layerMask.begin() , layerMask.end() , chamber.m_layerId ) != layerMask.end() )
				continue;

			chamber.m_x0 = atof( row[1] );
			chamber.m_y0 = atof( row[2] );
			chamber.m_z0 = atof( row[3] );
			chamber.m_x1 = atof( row[4] );
			chamber.m_y1 = atof( row[5] );
			chamber.m_z1 = atof( row[6] );

			geometry[chamber.m_layerId] = chamber;
		}
	});

	query.str("");
	query << "select NUM,(SELECT NUM FROM CHAMBERS WHERE CHAMBERS.IDX=DIFS.CHAMBERID),DI,DJ,POLI,POLJ FROM DIFS WHERE (SELECT NUM FROM CHAMBERS WHERE CHAMBERS.IDX=DIFS.CHAMBERID) IS NOT NULL AND VERSIONID="<<versionId<<";";

	// query dif list within chambers
	this->queryAndHandle(query.str(), [&] (MYSQL_RES *pMySQLResult)
	{
		MYSQL_ROW row;

		while( (row = mysql_fetch_row(pMySQLResult)) )
		{
			DifGeometry dif;

			dif.m_difId = atoi( row[0] );

			if( std::find( difMask.begin() , difMask.end() , dif.m_difId ) != difMask.end() )
				continue;

			dif.m_layerId = atoi( row[1] );
			dif.m_shiftX = atoi( row[2] );
			dif.m_shiftY = atoi( row[3] );

			std::map<unsigned int, ChamberGeometry>::iterator chIter = geometry.find( dif.m_layerId );

			if( chIter == geometry.end() )
				continue;

			chIter->second.m_difList[ dif.m_difId ] = dif;
		}
	});

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode GeometryDBInterface::dumpGeometry(const std::string &fileName, const std::string &testName,
		const dqm4hep::UIntVector &layerMask , const dqm4hep::UIntVector &difMask)
{
	std::map<unsigned int, ChamberGeometry> geometry;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->queryGeometry(testName, geometry, layerMask, difMask));

	GeometryXmlIO writer;
	return writer.saveAs(fileName, geometry);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode GeometryXmlIO::saveAs(const std::string &fileName, const std::map<unsigned int, ChamberGeometry> &geometry,
		const dqm4hep::UIntVector &layerMask, const dqm4hep::UIntVector &difMask)
{
	dqm4hep::TiXmlDocument document;

	dqm4hep::TiXmlDeclaration *pDeclaration = new dqm4hep::TiXmlDeclaration( "1.0", "", "" );
	document.LinkEndChild(pDeclaration);

	dqm4hep::TiXmlElement *pRootElement = new dqm4hep::TiXmlElement("sdhcalGeometry");
	document.LinkEndChild(pRootElement);

	for( std::map<unsigned int, ChamberGeometry>::const_iterator iter = geometry.begin(), endIter = geometry.end() ;
			endIter != iter ; ++iter )
	{
		if( std::find( layerMask.begin() , layerMask.end() , iter->first ) != layerMask.end() )
			continue;

		dqm4hep::TiXmlElement *pLayerElement = new dqm4hep::TiXmlElement("layer");

		pLayerElement->SetAttribute("id", iter->second.m_layerId);
		pLayerElement->SetAttribute("x0", iter->second.m_x0);
		pLayerElement->SetAttribute("y0", iter->second.m_y0);
		pLayerElement->SetAttribute("z0", iter->second.m_z0);
		pLayerElement->SetAttribute("x1", iter->second.m_x1);
		pLayerElement->SetAttribute("y1", iter->second.m_y1);
		pLayerElement->SetAttribute("z1", iter->second.m_z1);

		pRootElement->LinkEndChild(pLayerElement);

		for(std::map<unsigned int, DifGeometry>::const_iterator difIter = iter->second.m_difList.begin() , endDifIter = iter->second.m_difList.end() ;
				endDifIter != difIter ; ++difIter )
		{
			if( std::find( difMask.begin() , difMask.end() , difIter->first ) != difMask.end() )
				continue;

			dqm4hep::TiXmlElement *pDifElement = new dqm4hep::TiXmlElement("dif");

			pDifElement->SetAttribute("id", difIter->second.m_difId);
			pDifElement->SetAttribute("shiftX", difIter->second.m_shiftX);
			pDifElement->SetAttribute("shiftY", difIter->second.m_shiftY);

			pLayerElement->LinkEndChild(pDifElement);
		}
	}

	document.SaveFile(fileName);

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode GeometryXmlIO::load(const std::string &fileName, std::map<unsigned int, ChamberGeometry> &geometry,
		const dqm4hep::UIntVector &layerMask, const dqm4hep::UIntVector &difMask)
{
	dqm4hep::TiXmlDocument document(fileName);

	if( ! document.LoadFile() )
		return dqm4hep::STATUS_CODE_FAILURE;

    const dqm4hep::TiXmlHandle xmlDocumentHandle(&document);
    const dqm4hep::TiXmlHandle xmlHandle(xmlDocumentHandle.FirstChildElement().Element());

    for (dqm4hep::TiXmlElement *pLayerXmlElement = xmlHandle.FirstChild("layer").Element(); NULL != pLayerXmlElement;
        pLayerXmlElement = pLayerXmlElement->NextSiblingElement("layer"))
    {
    	dqm4hep::TiXmlHandle layerHandle(pLayerXmlElement);

    	ChamberGeometry chamber;

    	pLayerXmlElement->QueryValueAttribute<unsigned int>("id", &chamber.m_layerId);

		if( std::find( layerMask.begin() , layerMask.end() , chamber.m_layerId ) != layerMask.end() )
			continue;

    	pLayerXmlElement->QueryValueAttribute<float>("x0", &chamber.m_x0);
    	pLayerXmlElement->QueryValueAttribute<float>("y0", &chamber.m_y0);
    	pLayerXmlElement->QueryValueAttribute<float>("z0", &chamber.m_z0);
    	pLayerXmlElement->QueryValueAttribute<float>("x1", &chamber.m_x1);
    	pLayerXmlElement->QueryValueAttribute<float>("y1", &chamber.m_y1);
    	pLayerXmlElement->QueryValueAttribute<float>("z1", &chamber.m_z1);

        for (dqm4hep::TiXmlElement *pDifXmlElement = layerHandle.FirstChild("dif").Element(); NULL != pDifXmlElement;
            pDifXmlElement = pDifXmlElement->NextSiblingElement("dif"))
        {
        	DifGeometry dif;

        	pDifXmlElement->QueryValueAttribute<unsigned int>("id", &dif.m_difId);

			if( std::find( difMask.begin() , difMask.end() , dif.m_difId ) != difMask.end() )
				continue;

        	pDifXmlElement->QueryValueAttribute<unsigned int>("shiftX", &dif.m_shiftX);
        	pDifXmlElement->QueryValueAttribute<unsigned int>("shiftY", &dif.m_shiftY);

        	chamber.m_difList[ dif.m_difId ] = dif;
        }

        geometry[ chamber.m_layerId ] = chamber;
    }

	return dqm4hep::STATUS_CODE_SUCCESS;
}

} 

