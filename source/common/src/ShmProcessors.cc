  /// \file ShmProcessors.cc
/*
 *
 * ShmProcessors.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 14 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ShmProcessors.h"
#include "DIF.h"
#include "DIFUnpacker.h"

// -- dqm4hep headers
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMCoreTool.h"

// -- lcio headers
#include "EVENT/LCIO.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCParameters.h"
#include "IMPL/LCEventImpl.h"
#include "IMPL/LCCollectionVec.h"
#include "IMPL/LCFlagImpl.h"
#include "IMPL/RawCalorimeterHitImpl.h"

// -- std headers
#include <bitset>

namespace dqm_sdhcal
{

DQM_PLUGIN_DECL( EventInfoShmProcessor , "EventInfoShmProcessor" )
DQM_PLUGIN_DECL( SDHCALShmProcessor    , "SDHCALShmProcessor"    )
DQM_PLUGIN_DECL( CherenkovShmProcessor , "CherenkovShmProcessor" )

EventInfoShmProcessor::EventInfoShmProcessor() :
		m_eventNumber(0),
		m_runNumber(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

EventInfoShmProcessor::~EventInfoShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	m_runNumber = pRun->getRunNumber();
	m_detectorName = pRun->getDetectorName();
	m_eventNumber = 0;

	LOG4CXX_INFO( dqm4hep::dqmMainLogger , "===== Starting new run " << m_runNumber << " , detector name : " << m_detectorName << " ====" );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , "===== Ending run " << pRun->getRunNumber() << " , detector name : " << m_detectorName << " ====" );
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , "===== N processed events : " << m_eventNumber );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	pLCEvent->setEventNumber( m_eventNumber );
	pLCEvent->setRunNumber( m_runNumber );
	pLCEvent->setDetectorName( m_detectorName );
	pLCEvent->setTimeStamp(key);

	// set event creation time is parameters
	time_t currentTime = std::chrono::system_clock::to_time_t(dqm4hep::DQMCoreTool::now());
	pLCEvent->parameters().setValue( m_creationTimeParameterName , static_cast<int>(currentTime) );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_creationTimeParameterName = "CREATION_TIME";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CreationTimeParameterName", m_creationTimeParameterName));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


DIFPtr *SDHCALDifHelper::createDIFPtr(levbdim::buffer *pBuffer, unsigned int xdaqShift)
{
	uint32_t idstart = DIFUnpacker::getStartOfDIF((unsigned char*) pBuffer->ptr(), pBuffer->size(), xdaqShift);
	DIFPtr *pDifPtr = new DIFPtr( (unsigned char*) &pBuffer->ptr()[idstart] , pBuffer->size() - idstart + 1 );
	return pDifPtr;
}

//-------------------------------------------------------------------------------------------------

IMPL::RawCalorimeterHitImpl *SDHCALDifHelper::createRawCalorimeterHit(DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	std::bitset<6> channelBitSet(channel);
	unsigned long int cellID0(0);
	unsigned long int cellID1(0);
	unsigned long module(0);  // 0 for beam tests

	unsigned short difId        = (((unsigned short) pDifPtr->getID()) & 0xFF);
	unsigned short asicId       = (((unsigned short) pDifPtr->getFrameAsicHeader(frame)<<8)&0xFF00);
	unsigned long int channelId = ((channelBitSet.to_ulong()<<16)&0x3F0000);
	unsigned long int barrelEndcapModule = ((module <<22)&0xFC00000);
	unsigned long int timeStamp = (unsigned long int)(pDifPtr->getFrameTimeToTrigger(frame));

	cellID0 += (unsigned long int) difId;
	cellID0 += (unsigned long int) asicId;
	cellID0 += (unsigned long int) channelId;
	cellID0 += (unsigned long int) barrelEndcapModule;
	cellID1  = (unsigned long int) pDifPtr->getFrameBCID(frame);

	std::bitset<3> threshold;
	threshold[0] = pDifPtr->getFrameLevel(frame, channel, 0);
	threshold[1] = pDifPtr->getFrameLevel(frame, channel, 1);
	threshold[2] = false; // not synchronized

	// create raw calorimeter hit
	IMPL::RawCalorimeterHitImpl *pCaloHit = new IMPL::RawCalorimeterHitImpl();

	pCaloHit->setCellID0(cellID0);
	pCaloHit->setCellID1(cellID1);
	pCaloHit->setAmplitude(threshold.to_ulong());
	pCaloHit->setTimeStamp(timeStamp);

	return pCaloHit;
}

//-------------------------------------------------------------------------------------------------

bool SDHCALDifHelper::isEmptyPad(DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	return ( ! ( pDifPtr->getFrameLevel(frame, channel, 0) || pDifPtr->getFrameLevel(frame, channel, 1) ) );
}

//-------------------------------------------------------------------------------------------------

void SDHCALDifHelper::fillDifTriggerInfo(DIFPtr *pDifPtr, dqm4hep::IntVector &trigger)
{
	trigger.push_back(pDifPtr->getDTC());
	trigger.push_back(pDifPtr->getGTC());
	trigger.push_back(pDifPtr->getBCID());
	trigger.push_back(pDifPtr->getAbsoluteBCID()&0xFFFFFF);
	trigger.push_back((pDifPtr->getAbsoluteBCID()/(0xFFFFFF+1))&0xFFFFFF);
	trigger.push_back(pDifPtr->getTASU1());
	trigger.push_back(pDifPtr->getTASU2());
	trigger.push_back(pDifPtr->getTDIF());
}

//-------------------------------------------------------------------------------------------------

void SDHCALDifHelper::setLCFlag(IMPL::LCFlagImpl &lcFlag)
{
	EVENT::LCIO bitinfo;
	lcFlag.setBit( bitinfo.RCHBIT_LONG );  // raw calorimeter data -> format long
	lcFlag.setBit( bitinfo.RCHBIT_BARREL ); // barrel
	lcFlag.setBit( bitinfo.RCHBIT_ID1 ); // cell ID 1
	lcFlag.setBit( bitinfo.RCHBIT_TIME ); // timestamp
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

SDHCALShmProcessor::SDHCALShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SDHCALShmProcessor::~SDHCALShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	IMPL::LCFlagImpl chFlag(0);
	SDHCALDifHelper::setLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::RAWCALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	bool isFirstRU = true;
	bool reachedNoiseLimit = false;

	// loop over dif raw buffers and convert to raw calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		if( reachedNoiseLimit )
			break;

		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
			continue;

		if( isFirstRU && m_dropFirstRU )
		{
			isFirstRU = false;
			continue;
		}

		// create dif pointer to extract info
		DIFPtr *pDifPtr = SDHCALDifHelper::createDIFPtr(pBuffer, m_xdaqShift);

		// check for dif mask
		unsigned int difId = pDifPtr->getID();

		if( m_difMaskList.find(difId) != m_difMaskList.end() )
		{
			delete pDifPtr;
			continue;
		}

		// loop over frames
		for(uint32_t f=0 ; f<pDifPtr->getNumberOfFrames() ; f++)
		{
			if( reachedNoiseLimit )
				break;

			// loop over hits
			for(uint32_t ch=0 ; ch<64 ; ch++)
			{
				// skip empty pads
				if ( SDHCALDifHelper::isEmptyPad(pDifPtr, f, ch) )
					continue;

				EVENT::RawCalorimeterHit *pCaloHit = SDHCALDifHelper::createRawCalorimeterHit(pDifPtr, f, ch);
				pOutputCollection->addElement(pCaloHit);

				if (pOutputCollection->getNumberOfElements() > m_noiseLimit)
				{
					reachedNoiseLimit = true;
					break;
				}
			}
		}

		// store trigger info in collection
		dqm4hep::IntVector trigger;
		std::stringstream triggerParameterName;

		SDHCALDifHelper::fillDifTriggerInfo(pDifPtr, trigger);
		triggerParameterName << "DIF" << pDifPtr->getID() << "_Triggers";

		pOutputCollection->parameters().setValues(triggerParameterName.str(), trigger);

		delete pDifPtr;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_skipFullAsics = true;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"SkipFullAsics", m_skipFullAsics));

	m_dropFirstRU = true;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DropFirstRU", m_dropFirstRU));

	m_noiseLimit = 100000;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NoiseLimit", m_noiseLimit));

	m_xdaqShift = 24;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"XDaqShift", m_xdaqShift));

	m_detectorId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "DHCALRawHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	dqm4hep::UIntVector difMaskList;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"DifMaskList", difMaskList));

	m_difMaskList.insert( difMaskList.begin(), difMaskList.end() );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

CherenkovShmProcessor::CherenkovShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

CherenkovShmProcessor::~CherenkovShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::startOfRun(dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::endOfRun(const dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	IMPL::LCFlagImpl chFlag(0);
	SDHCALDifHelper::setLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::RAWCALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	// loop over dif raw buffers
	// find the cherenkov dif
	// convert to raw calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
			continue;

		// create dif pointer to extract info
		DIFPtr *pDifPtr = SDHCALDifHelper::createDIFPtr(pBuffer, m_xdaqShift);

		// check for dif mask
		unsigned int difId = pDifPtr->getID();

		if( m_cherenkovDifId != difId )
		{
			delete pDifPtr;
			continue;
		}

		// loop over frames
		for(uint32_t f=0 ; f<pDifPtr->getNumberOfFrames() ; f++)
		{
			// loop over hits
			for(uint32_t ch=0 ; ch<64 ; ch++)
			{
				// skip empty pads
				if ( SDHCALDifHelper::isEmptyPad(pDifPtr, f, ch) )
					continue;

				IMPL::RawCalorimeterHitImpl *pCaloHit = SDHCALDifHelper::createRawCalorimeterHit(pDifPtr, f, ch);
				int timeStamp = pCaloHit->getTimeStamp();

				// apply cherenkov time stamp shift
				if(m_cherenkovTimeShift < 0 && timeStamp < abs(m_cherenkovTimeShift) )
				{
					LOG4CXX_WARN( dqm4hep::dqmMainLogger , "Reconstructed cherenkov hit with timeStamp = " << timeStamp << ", adding shift of " << m_cherenkovTimeShift << " resulting in negative time stamp !!" );
					LOG4CXX_WARN( dqm4hep::dqmMainLogger , "Setting time stamp of cherenkov hit to 0 !" );
					pCaloHit->setTimeStamp(0);
				}
				else
					pCaloHit->setTimeStamp( timeStamp + m_cherenkovTimeShift );

				pOutputCollection->addElement(pCaloHit);
			}
		}

		// store trigger info in collection
		dqm4hep::IntVector trigger;
		std::stringstream triggerParameterName;

		SDHCALDifHelper::fillDifTriggerInfo(pDifPtr, trigger);
		triggerParameterName << "Cherenkov_DIF" << pDifPtr->getID() << "_Triggers";

		pOutputCollection->parameters().setValues(triggerParameterName.str(), trigger);

		delete pDifPtr;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_xdaqShift = 24;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"XDaqShift", m_xdaqShift));

	m_detectorId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "CherenkovRawHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	m_cherenkovDifId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CherenkovDifId", m_cherenkovDifId));

	m_cherenkovTimeShift = 0;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CherenkovTimeShift", m_cherenkovTimeShift));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

} 

