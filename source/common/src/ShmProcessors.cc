  /// \file ShmProcessors.cc
/*
 *
 * ShmProcessors.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 14 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ShmProcessors.h"
#include "DIF.h"
#include "DIFUnpacker.h"

// -- dqm4hep headers
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMCoreTool.h"

// -- lcio headers
#include "EVENT/LCIO.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCParameters.h"
#include "IMPL/LCEventImpl.h"
#include "IMPL/LCCollectionVec.h"
#include "IMPL/LCFlagImpl.h"
#include "IMPL/RawCalorimeterHitImpl.h"
#include "IMPL/CalorimeterHitImpl.h"
#include "UTIL/CellIDEncoder.h"

// -- std headers
#include <bitset>

namespace dqm_sdhcal
{

DQM_PLUGIN_DECL( EventInfoShmProcessor , "EventInfoShmProcessor" )
DQM_PLUGIN_DECL( SDHCALShmProcessor    , "SDHCALShmProcessor"    )
DQM_PLUGIN_DECL( CherenkovShmProcessor , "CherenkovShmProcessor" )
DQM_PLUGIN_DECL( SiWECalShmProcessor   , "SiWECalShmProcessor"   )

EventInfoShmProcessor::EventInfoShmProcessor() :
		m_eventNumber(0),
		m_runNumber(0),
		m_moduleLogStr("[EventInfoShmProcessor]")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

EventInfoShmProcessor::~EventInfoShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	m_runNumber = pRun->getRunNumber();
	m_detectorName = pRun->getDetectorName();
	m_eventNumber = 0;

	LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - ===== Starting new run " << m_runNumber << " , detector name : " << m_detectorName << " ====" );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - ===== Ending run " << pRun->getRunNumber() << " , detector name : " << m_detectorName << " ====" );
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - ===== N processed events : " << m_eventNumber );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	pLCEvent->setEventNumber( m_eventNumber );
	pLCEvent->setRunNumber( m_runNumber );
	pLCEvent->setDetectorName( m_detectorName );

	// set event creation time is parameters
	time_t currentTime = std::chrono::system_clock::to_time_t(dqm4hep::DQMCoreTool::now());
	pLCEvent->parameters().setValue( m_creationTimeParameterName , static_cast<int>(currentTime) );
	pLCEvent->setTimeStamp(currentTime);

	m_eventNumber++;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_creationTimeParameterName = "CREATION_TIME";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CreationTimeParameterName", m_creationTimeParameterName));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


DIFPtr *SDHCALDifHelper::createDIFPtr(levbdim::buffer *pBuffer, unsigned int xdaqShift)
{
	uint32_t idstart = DIFUnpacker::getStartOfDIF((unsigned char*) pBuffer->ptr(), pBuffer->size(), xdaqShift);
	DIFPtr *pDifPtr = new DIFPtr( (unsigned char*) &pBuffer->ptr()[idstart] , pBuffer->size() - idstart + 1 );
	return pDifPtr;
}

//-------------------------------------------------------------------------------------------------

bool SDHCALDifHelper::isEmptyPad(DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	return ( ! ( pDifPtr->getFrameLevel(frame, channel, 0) || pDifPtr->getFrameLevel(frame, channel, 1) ) );
}

//-------------------------------------------------------------------------------------------------

void SDHCALDifHelper::fillDifTriggerInfo(DIFPtr *pDifPtr, dqm4hep::IntVector &trigger)
{
	trigger.push_back(pDifPtr->getDTC());
	trigger.push_back(pDifPtr->getGTC());
	trigger.push_back(pDifPtr->getBCID());
	trigger.push_back(pDifPtr->getAbsoluteBCID()&0xFFFFFF);
	trigger.push_back((pDifPtr->getAbsoluteBCID()/(0xFFFFFF+1))&0xFFFFFF);
	trigger.push_back(pDifPtr->getTASU1());
	trigger.push_back(pDifPtr->getTASU2());
	trigger.push_back(pDifPtr->getTDIF());
}

//-------------------------------------------------------------------------------------------------

void SDHCALDifHelper::setCaloHitLCFlag(IMPL::LCFlagImpl &lcFlag)
{
	EVENT::LCIO bitinfo;
	lcFlag.setBit( bitinfo.RCHBIT_LONG );  // raw calorimeter data -> format long
	lcFlag.setBit( bitinfo.RCHBIT_BARREL ); // barrel
	lcFlag.setBit( bitinfo.RCHBIT_ID1 ); // cell ID 1
	lcFlag.setBit( bitinfo.RCHBIT_TIME ); // timestamp
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

SDHCALShmProcessor::SDHCALShmProcessor():
		m_moduleLogStr("[SDHCALShmProcessor]")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SDHCALShmProcessor::~SDHCALShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}
	LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - newLCEvent...with key '"<<key<<"' and creationTime: '"<<pLCEvent->getTimeStamp()<<"'" );

	IMPL::LCFlagImpl chFlag(0);
	SDHCALDifHelper::setCaloHitLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::CALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> cellIDEncoder( m_cellIDEncoderString , pOutputCollection );

	bool isFirstRU = true;
	bool reachedNoiseLimit = false;

	// loop over dif raw buffers and convert to raw calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		if( reachedNoiseLimit )
			break;

		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
		{
			LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong detectorID : pBuffer->detectorId(): " <<pBuffer->detectorId()<< " != m_detectorId " << m_detectorId );
			continue;
		}

		if( isFirstRU && m_dropFirstRU )
		{
			isFirstRU = false;
			continue;
		}

		// create dif pointer to extract info
		DIFPtr *pDifPtr = SDHCALDifHelper::createDIFPtr(pBuffer, m_xdaqShift);

		// check for dif mask
		unsigned int difId = pDifPtr->getID();
		// Change timeStamp to the trigger timeStamp
		pLCEvent->setTimeStamp(pDifPtr->getBCID());

		if( m_difMaskList.find(difId) != m_difMaskList.end() )
		{
			delete pDifPtr;
			continue;
		}

		// loop over frames
		for(uint32_t f=0 ; f<pDifPtr->getNumberOfFrames() ; f++)
		{
			if( reachedNoiseLimit )
				break;

			// loop over hits
			for(uint32_t ch=0 ; ch<64 ; ch++)
			{
				// skip empty pads
				if ( SDHCALDifHelper::isEmptyPad(pDifPtr, f, ch) )
					continue;

				EVENT::CalorimeterHit *pCaloHit = this->createCalorimeterHit(cellIDEncoder, pDifPtr, f, ch);

				if(0 == pCaloHit)
					continue;

				pOutputCollection->addElement(pCaloHit);

				if (pOutputCollection->getNumberOfElements() > m_noiseLimit)
				{
					reachedNoiseLimit = true;
					break;
				}
			}
		}

		// store trigger info in collection
		dqm4hep::IntVector trigger;
		std::stringstream triggerParameterName;

		SDHCALDifHelper::fillDifTriggerInfo(pDifPtr, trigger);
		triggerParameterName << "DIF" << pDifPtr->getID() << "_Triggers";

		pOutputCollection->parameters().setValues(triggerParameterName.str(), trigger);

		delete pDifPtr;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

IMPL::CalorimeterHitImpl *SDHCALShmProcessor::createCalorimeterHit(UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> &cellIDEncoder, DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	// dif - asic - channel
	unsigned short difId        = pDifPtr->getID();
	unsigned short asicId       = pDifPtr->getFrameAsicHeader(frame);
	unsigned long int channelId = channel;

	// time stamp  - unit = bin of 200 ns from trigger
	const float timeStamp  = static_cast<float>(pDifPtr->getFrameTimeToTrigger(frame));
	
	if ( timeStamp - pDifPtr->getBCID() > 0) 
	{
 		LOG4CXX_ERROR( dqm4hep::dqmMainLogger, m_moduleLogStr << " - Funny hitTimestamp : " << (unsigned long int)(pDifPtr->getFrameTimeToTrigger(frame)) << "\t BCID : " << pDifPtr->getBCID() << "\t ABCID : " << (pDifPtr->getAbsoluteBCID()&0xFFFFFF));
	}

	// get the SDHCAL threshold
	std::bitset<3> threshold;
	threshold[0] = pDifPtr->getFrameLevel(frame, channel, 0);
	threshold[1] = pDifPtr->getFrameLevel(frame, channel, 1);
	threshold[2] = false;

	float shift;
	const float amplitude( static_cast<float>( threshold.to_ulong() & m_amplitudeBitRotation ) );

  if( amplitude > 2.5 )
		shift = 0;         // 3rd threshold
  else if( amplitude > 1.5 )
		shift = -1;        // 2nd threshold
	else
		shift = +1;        // 1rst Threshold

  const float energy(amplitude + shift);

  // perform conversion to cell ids and absolute position
  dqm4hep::DQMElectronicsMapping::Electronics electronics;
  electronics.m_difId = difId;
  electronics.m_asicId = asicId;
  electronics.m_channelId = channelId;

	dqm4hep::DQMCartesianVector position(0.f, 0.f, 0.f);
	dqm4hep::DQMElectronicsMapping::Cell cell;

	try
	{
		THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicsToPosition(electronics, position));
		THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicstoCell(electronics, cell));
	}
	catch(dqm4hep::StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger, m_moduleLogStr << " - Couldn't decode hit using electronics mapping : " << exception.toString() );
		return 0;
	}
	catch(...)
	{
		LOG4CXX_FATAL( dqm4hep::dqmMainLogger, m_moduleLogStr << " - Caught Unknown exception " );
		return 0;
	}

	try
	{
		// set the cell id
		cellIDEncoder[ m_ijkEncoding.at(0) ] = cell.m_iCell;
		cellIDEncoder[ m_ijkEncoding.at(1) ] = cell.m_jCell;
		cellIDEncoder[ m_ijkEncoding.at(2) ] = cell.m_layer;

	    if( m_encodeDifAsicChannel )
		{
			cellIDEncoder[ m_difAsicChannelEncoding.at(0) ] = electronics.m_difId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(1) ] = electronics.m_asicId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(2) ] = electronics.m_channelId;
		}
	}
	catch(EVENT::Exception &e)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger, m_moduleLogStr << " - While encoding hits, EVENT::Exception caught : " << e.what() );
		return 0;
	}

    // set the position
	float positionArray [3] = { position.getX() , position.getY() , position.getZ() };

	// create the calorimeter hit
	IMPL::CalorimeterHitImpl *pCaloHit = new IMPL::CalorimeterHitImpl();
	pCaloHit->setPosition( positionArray );
	pCaloHit->setEnergy(energy);
	cellIDEncoder.setCellID( pCaloHit );
	pCaloHit->setTime(timeStamp);

	return pCaloHit;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	dqm4hep::TiXmlElement *pMappingXmlElement = xmlHandle.FirstChild("electronicsMapping").Element();

	if( ! pMappingXmlElement )
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " -  Couldn't find xml element electronicsMapping !" );
		return dqm4hep::STATUS_CODE_NOT_FOUND;
  }

	std::string plugin;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::getAttribute(pMappingXmlElement, "plugin", plugin));

	// query electronics mapping plugin instance and configure
	m_pElectronicsMapping = dqm4hep::DQMPluginManager::instance()->createPluginClass<dqm4hep::DQMElectronicsMapping>(plugin);

	dqm4hep::TiXmlHandle mappingHandle(pMappingXmlElement);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->readSettings(mappingHandle));

	m_amplitudeBitRotation = 3;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"AmplitudeBitRotation", m_amplitudeBitRotation));

	m_encodeDifAsicChannel = true;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"EncodeDifAsicChannel", m_encodeDifAsicChannel));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"IJKEncoding", m_ijkEncoding, [&] (const dqm4hep::StringVector &vec) {
		return vec.size() == 3;
	}));

	m_cellIDEncoderString = "M:3,S-1:3,I:9,J:9,K-1:6";

	if( m_encodeDifAsicChannel )
	{
		m_cellIDEncoderString = "I:7,J:7,K-1:6,Dif_id:8,Asic_id:8,Chan_id:6";

		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
				"DifAsicChannelEncoding", m_difAsicChannelEncoding, [&] (const dqm4hep::StringVector &vec) {
			return vec.size() == 3;
		}));
	}

	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CellIDEncoderString", m_cellIDEncoderString));

	m_skipFullAsics = true;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"SkipFullAsics", m_skipFullAsics));

	m_dropFirstRU = true;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DropFirstRU", m_dropFirstRU));

	m_noiseLimit = 100000;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NoiseLimit", m_noiseLimit));

	m_xdaqShift = 24;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"XDaqShift", m_xdaqShift));

	m_detectorId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "DHCALRawHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	dqm4hep::UIntVector difMaskList;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"DifMaskList", difMaskList));

	m_difMaskList.insert( difMaskList.begin(), difMaskList.end() );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

CherenkovShmProcessor::CherenkovShmProcessor() :
		m_moduleLogStr("[CherenkovShmProcessor]")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

CherenkovShmProcessor::~CherenkovShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::startOfRun(dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::endOfRun(const dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	IMPL::LCFlagImpl chFlag(0);
	SDHCALDifHelper::setCaloHitLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::RAWCALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	// loop over dif raw buffers
	// find the cherenkov dif
	// convert to raw calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
			continue;

		// create dif pointer to extract info
		DIFPtr *pDifPtr = SDHCALDifHelper::createDIFPtr(pBuffer, m_xdaqShift);

		// check for dif mask
		unsigned int difId = pDifPtr->getID();

		if( m_cherenkovDifId != difId )
		{
			delete pDifPtr;
			continue;
		}

		// loop over frames
		for(uint32_t f=0 ; f<pDifPtr->getNumberOfFrames() ; f++)
		{
			// loop over hits
			for(uint32_t ch=0 ; ch<64 ; ch++)
			{
				// skip empty pads
				if ( SDHCALDifHelper::isEmptyPad(pDifPtr, f, ch) )
					continue;

				IMPL::CalorimeterHitImpl *pCaloHit = this->createCalorimeterHit(pDifPtr, f, ch);
				float timeStamp = pCaloHit->getTime();

				// apply cherenkov time stamp shift
				if(m_cherenkovTimeShift < 0 && timeStamp < abs(m_cherenkovTimeShift) )
				{
					LOG4CXX_WARN( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Reconstructed cherenkov hit with timeStamp = " << timeStamp << ", adding shift of " << m_cherenkovTimeShift << " resulting in negative time stamp !!" );
					LOG4CXX_WARN( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Setting time stamp of cherenkov hit to 0 !" );
					pCaloHit->setTime(0.f);
				}
				else
					pCaloHit->setTime( timeStamp + m_cherenkovTimeShift );

				pOutputCollection->addElement(pCaloHit);
			}
		}

		// store trigger info in collection
		dqm4hep::IntVector trigger;
		std::stringstream triggerParameterName;

		SDHCALDifHelper::fillDifTriggerInfo(pDifPtr, trigger);
		triggerParameterName << "Cherenkov_DIF" << pDifPtr->getID() << "_Triggers";

		pOutputCollection->parameters().setValues(triggerParameterName.str(), trigger);

		delete pDifPtr;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

IMPL::CalorimeterHitImpl *CherenkovShmProcessor::createCalorimeterHit(DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	std::bitset<6> channelBitSet(channel);
	unsigned long int cellID0(0);
	unsigned long int cellID1(0);
	unsigned long module(0);  // 0 for beam tests

	unsigned short difId        = (((unsigned short) pDifPtr->getID()) & 0xFF);
	unsigned short asicId       = (((unsigned short) pDifPtr->getFrameAsicHeader(frame)<<8)&0xFF00);
	unsigned long int channelId = ((channelBitSet.to_ulong()<<16)&0x3F0000);
	unsigned long int barrelEndcapModule = ((module <<22)&0xFC00000);

	const float timeStamp = static_cast<float>(pDifPtr->getFrameTimeToTrigger(frame));

	cellID0 += (unsigned long int) difId;
	cellID0 += (unsigned long int) asicId;
	cellID0 += (unsigned long int) channelId;
	cellID0 += (unsigned long int) barrelEndcapModule;
	cellID1  = (unsigned long int) pDifPtr->getFrameBCID(frame);

	std::bitset<3> threshold;
	threshold[0] = pDifPtr->getFrameLevel(frame, channel, 0);
	threshold[1] = pDifPtr->getFrameLevel(frame, channel, 1);
	threshold[2] = false; // not synchronized

	float shift;
	const float amplitude( static_cast<float>( threshold.to_ulong() & m_amplitudeBitRotation ) );

    if( amplitude > 2.5 )
		shift = 0;         // 3rd threshold
    else if( amplitude > 1.5 )
		shift = -1;        // 2nd threshold
	else
		shift = +1;        // 1rst Threshold

    const float energy(amplitude + shift);

	float positionArray [3] = {0};

	// create the calorimeter hit
	IMPL::CalorimeterHitImpl *pCaloHit = new IMPL::CalorimeterHitImpl();

	pCaloHit->setCellID0(cellID0);
	pCaloHit->setPosition(positionArray);
	pCaloHit->setEnergy(energy);
	pCaloHit->setTime(timeStamp);

	return pCaloHit;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_xdaqShift = 24;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"XDaqShift", m_xdaqShift));

	m_detectorId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "CherenkovRawHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	m_cherenkovDifId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CherenkovDifId", m_cherenkovDifId));

	m_cherenkovTimeShift = 0;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CherenkovTimeShift", m_cherenkovTimeShift));

	m_amplitudeBitRotation = 3;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"AmplitudeBitRotation", m_amplitudeBitRotation));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

SiWECalShmProcessor::SiWECalShmProcessor() :
		m_positionShift(0.f, 0.f, 0.f),
		m_moduleLogStr("[SiWECalShmProcessor]")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SiWECalShmProcessor::~SiWECalShmProcessor()
{

}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	IMPL::LCFlagImpl chFlag(0);
	SiWECalShmProcessor::setCaloHitLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::RAWCALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> cellIDEncoder( m_cellIDEncoderString , pOutputCollection );

	// loop over dif raw buffers
	// decode hits one by one
	// convert to calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
			continue;

		SiWECalRawHit *rawHit = 0;

		unsigned char *pRawBuffer = (unsigned char*) pBuffer->ptr();
		uint32_t bufferSize = pBuffer->size();

		if(0 == bufferSize)
			continue;

		int32_t invalidBuffer = ( bufferSize - sizeof(struct SiWECalHeader) ) % sizeof(struct SiWECalRawHit);

		if(invalidBuffer)
		{
			LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Invalid SiWECal DIF ptr : Invalid buffer size = " << bufferSize );
			continue;
		}

		const unsigned int nECalHits(( bufferSize - sizeof(struct SiWECalHeader) ) / sizeof(struct SiWECalRawHit));

		unsigned int difId (0);
		unsigned int difSpill(0);

		for(unsigned int i=0 ; i<nECalHits ; ++i)
		{
			rawHit = (SiWECalRawHit *) (pRawBuffer + sizeof(struct SiWECalHeader) + i*sizeof(struct SiWECalRawHit));

			if(0 == i)
			{
				difId = rawHit->m_difId;
				difSpill = rawHit->m_spillId;
			}

			IMPL::CalorimeterHitImpl *pECalCaloHit = new IMPL::CalorimeterHitImpl();

			float position[3] = {
					rawHit->m_x + m_positionShift.getX(),
					rawHit->m_y + m_positionShift.getY(),
					rawHit->m_z + m_positionShift.getZ() };

			// set the cell id
			cellIDEncoder[ m_ijkEncoding.at(0) ] = rawHit->m_iCell;
			cellIDEncoder[ m_ijkEncoding.at(1) ] = rawHit->m_jCell;
			cellIDEncoder[ m_ijkEncoding.at(2) ] = rawHit->m_layer;
			cellIDEncoder[ m_difAsicChannelEncoding.at(0) ] = rawHit->m_difId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(1) ] = rawHit->m_asicId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(2) ] = rawHit->m_channelId;

			// TODO add adc to energy conversion here !
			float energy = static_cast<float>(rawHit->m_adcCount);
			float time = static_cast<float>(rawHit->m_bcid);

			cellIDEncoder.setCellID( pECalCaloHit );
			pECalCaloHit->setPosition(position);
			pECalCaloHit->setTime(time);
			pECalCaloHit->setEnergy(energy);

			pOutputCollection->addElement(pECalCaloHit);
		}

		std::stringstream ss;
		ss << "SIWECAL_DIF" << difId << "_Spill";

		pOutputCollection->parameters().setValue(ss.str(), static_cast<int>(difSpill));
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void SiWECalShmProcessor::setCaloHitLCFlag(IMPL::LCFlagImpl &lcFlag)
{
	EVENT::LCIO bitinfo;
	lcFlag.setBit( bitinfo.RCHBIT_LONG );  // calorimeter data -> format long (position)
	lcFlag.setBit( bitinfo.RCHBIT_BARREL ); // barrel
	lcFlag.setBit( bitinfo.RCHBIT_ID1 ); // cell ID 1
	lcFlag.setBit( bitinfo.RCHBIT_TIME ); // time
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_detectorId = 1100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "SiWECal";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	m_positionShift.setValues(0.f, 0.f, 0.f);
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"PositionShift", m_positionShift));

	m_cellIDEncoderString = "I:7,J:7,K-1:6,Dif_id:8,Asic_id:8,Chan_id:6";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CellIDEncoderString", m_cellIDEncoderString));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"IJKEncoding", m_ijkEncoding, [&] (const dqm4hep::StringVector &vec) {
		return vec.size() == 3;
	}));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"DifAsicChannelEncoding", m_difAsicChannelEncoding, [&] (const dqm4hep::StringVector &vec) {
		return vec.size() == 3;
	}));

	return dqm4hep::STATUS_CODE_SUCCESS;
}



} 

