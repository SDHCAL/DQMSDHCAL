  /// \file AnalysisTools.cc
/*
 *
 * AnalysisTools.cc source template automatically generated by a class generator
 * Creation date : ven. avr. 15 2016
 *
 * This file is part of DQMSHCAL libraries.
 * 
 * DQMSHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "AnalysisTools.h"

// -- dqm4hep headers
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMXmlHelper.h"

// -- lcio headers
#include "UTIL/CellIDDecoder.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCCollection.h"
#include "EVENT/CalorimeterHit.h"

namespace dqm_sdhcal
{

DQM_PLUGIN_DECL( SDHCALEventClassifier , "SDHCALEventClassifier" )

EventClassifier::EventClassifier() :
		m_eventType(UNDEFINED_EVENT),
		m_confidenceLevel(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

EventClassifier::~EventClassifier()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

bool EventClassifier::isNoisyEvent() const
{
	return ( m_eventType >= SQUARE_NOISE_EVENT && m_eventType <= GROUNDING_NOISE_EVENT );
}

//-------------------------------------------------------------------------------------------------

bool EventClassifier::isPhysicsEvent() const
{
	return ( m_eventType >= BEAM_MUON_EVENT && m_eventType <= HADRONIC_SHOWER_EVENT );
}

//-------------------------------------------------------------------------------------------------

bool EventClassifier::isMuonEvent() const
{
	return ( m_eventType >= BEAM_MUON_EVENT && m_eventType <= HADRONIC_SHOWER_EVENT );
}

//-------------------------------------------------------------------------------------------------

bool EventClassifier::isShowerEvent() const
{
	return ( m_eventType >= SHOWER_EVENT && m_eventType <= HADRONIC_SHOWER_EVENT );
}

//-------------------------------------------------------------------------------------------------

bool EventClassifier::isUndefined() const
{
	return ( m_eventType == UNDEFINED_EVENT );
}

//-------------------------------------------------------------------------------------------------

EventClassifier::EventType EventClassifier::getEventType() const
{
	return m_eventType;
}

//-------------------------------------------------------------------------------------------------

unsigned int EventClassifier::getConfidenceLevel() const
{
	return m_confidenceLevel;
}

//-------------------------------------------------------------------------------------------------

void EventClassifier::setEventType(EventClassifier::EventType type, unsigned int confidenceLevel)
{
	m_eventType = type;
	m_confidenceLevel = confidenceLevel;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

SDHCALEventClassifier::SDHCALEventClassifier() :
		EventClassifier()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALEventClassifier::processEvent(EVENT::LCEvent *pLCEvent)
{
	this->setEventType( EventClassifier::UNDEFINED_EVENT , 100 );

	try
	{
		EVENT::LCCollection *pLCCollection = pLCEvent->getCollection( m_inputCollectionName );
		UTIL::CellIDDecoder<EVENT::CalorimeterHit> cellIDDecoder(m_cellIDDecoderString);

		unsigned int nHits = pLCCollection->getNumberOfElements();

		if( 0 == nHits )
			return dqm4hep::STATUS_CODE_SUCCESS;

		std::set<int> touchedLayers;

		for(unsigned int e=0 ; e<pLCCollection->getNumberOfElements() ; e++)
		{
			EVENT::CalorimeterHit *pCaloHit = dynamic_cast<EVENT::CalorimeterHit *>(pLCCollection->getElementAt(e));

			if( NULL == pCaloHit )
				continue;

			int layer = cellIDDecoder(pCaloHit)["K-1"];
			touchedLayers.insert( layer );
		}

		float nHitPerTouchedLayers = static_cast<float>( pLCCollection->getNumberOfElements() ) / static_cast<float>( touchedLayers.size() );

		if( ( nHitPerTouchedLayers < m_noiseMinNHitPerTouchedLayer && nHits > m_noiseMinNHit )
		   || nHitPerTouchedLayers > m_noiseMaxNHitPerTouchedLayer )
		{
			this->setEventType( EventClassifier::GROUNDING_NOISE_EVENT , 100 );
			LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "SDHCALEventClassifier::processEvent: Found noise event !" )
			return dqm4hep::STATUS_CODE_SUCCESS;
		}

		// TODO do analysis for muons, electrons and hadrons
	}
	catch(EVENT::DataNotAvailableException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "SDHCALEventClassifier::processEvent: Collection " << m_inputCollectionName << " is not available !" );
		return dqm4hep::STATUS_CODE_NOT_FOUND;
	}
	catch(dqm4hep::StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "SDHCALEventClassifier::processEvent: Caught status code exception : " << exception.toString() );
		return exception.getStatusCode();
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALEventClassifier::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_inputCollectionName = "SDHCAL_HIT";
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"InputCollectionName", m_inputCollectionName));

	m_cellIDDecoderString = "I:7,J:7,K-1:6,Dif_id:8,Asic_id:8,Chan_id:6";
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CellIDDecoderString", m_cellIDDecoderString));

	m_noiseMinNHitPerTouchedLayer = 1.f;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NoiseMinNHitPerTouchedLayer", m_noiseMinNHitPerTouchedLayer));

	m_noiseMaxNHitPerTouchedLayer = 40.f;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NoiseMaxNHitPerTouchedLayer", m_noiseMaxNHitPerTouchedLayer));

	m_noiseMinNHit = 10;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NoiseMinNHit", m_noiseMinNHit));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

} 

