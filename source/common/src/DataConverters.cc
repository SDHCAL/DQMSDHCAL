/// \file DataConverters.cc
/*
 *
 * DataConverters.cc source template automatically generated by a class generator
 * Creation date : ven. avr. 8 2016
 *
 * This file is part of DQMSDHCAL libraries.
 *
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqmsdhcal headers
#include "DataConverters.h"

// -- dqm4hep headers
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMElectronicsMapping.h"
#include "dqm4hep/DQMXmlHelper.h"

// -- lcio headers
#include "UTIL/CellIDEncoder.h"

// -- dqm4ilc headers
#include "dqm4ilc/DQMLCHelper.h"

namespace dqm_sdhcal
{

// declare dqm plugin instance
DQM_PLUGIN_DECL(SDHCALCaloHitConverter, "SDHCALCaloHitConverter")

//-------------------------------------------------------------------------------------------------

SDHCALCaloHitConverter::SDHCALCaloHitConverter() :
	m_isInitialized(false)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SDHCALCaloHitConverter::~SDHCALCaloHitConverter()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALCaloHitConverter::convert(const EVENT::LCCollection *const pInputCollection, EVENT::LCCollection *const pOutputCollection)
{
	if( ! m_isInitialized )
		return dqm4hep::STATUS_CODE_NOT_INITIALIZED;

	if( pInputCollection->getTypeName() != EVENT::LCIO::RAWCALORIMETERHIT || pOutputCollection->getTypeName() != EVENT::LCIO::CALORIMETERHIT )
		return dqm4hep::STATUS_CODE_INVALID_PARAMETER;

	// Copy parameters from inputCollection to outputCollection
	dqm4ilc::DQMLCHelper::copyLCParameters( pInputCollection->getParameters() , pOutputCollection->parameters() );

	UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> cellIDEncoder( m_cellIDEncoderString , pOutputCollection );

	for(unsigned int e=0 ; e<pInputCollection->getNumberOfElements() ; e++)
	{
		EVENT::RawCalorimeterHit *pRawCaloHit = dynamic_cast<EVENT::RawCalorimeterHit *>(pInputCollection->getElementAt(e));

		if( NULL == pRawCaloHit )
			continue;

		int cellID = pRawCaloHit->getCellID0();
		unsigned int threshold = this->getThreshold( pRawCaloHit );

		dqm4hep::DQMElectronicsMapping::Electronics electronics;

		// extract raw data electronics ids
		electronics.m_difId = this->getDifId( cellID );
		electronics.m_asicId = this->getAsicId( cellID );
		electronics.m_channelId = this->getChannelId( cellID );

		// perform conversion to cell ids and absolute position
		dqm4hep::DQMCartesianVector position(0.f, 0.f, 0.f);
		dqm4hep::DQMElectronicsMapping::Cell cell;
		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicsToPosition(electronics, position));
		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicstoCell(electronics, cell));

		// set the cell id
		cellIDEncoder[ m_ijkEncoding.at(0) ] = cell.m_iCell;
		cellIDEncoder[ m_ijkEncoding.at(1) ] = cell.m_jCell;
		cellIDEncoder[ m_ijkEncoding.at(2) ] = cell.m_layer;

	    if( m_encodeDifAsicChannel )
		{
			cellIDEncoder[ m_difAsicChannelEncoding.at(0) ] = electronics.m_difId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(1) ] = electronics.m_asicId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(2) ] = electronics.m_channelId;
		}

		float positionArray [3] = { position.getX() , position.getY() , position.getZ() };

		// create hit and fill infos
		IMPL::CalorimeterHitImpl *pCaloHit = new IMPL::CalorimeterHitImpl();

		pCaloHit->setTime( static_cast<float>( pRawCaloHit->getTimeStamp() ) );
		pCaloHit->setEnergy( static_cast<float>( threshold ) );
		pCaloHit->setPosition( positionArray );
		cellIDEncoder.setCellID( pCaloHit );
		pCaloHit->setRawHit( pRawCaloHit );

		pOutputCollection->addElement( pCaloHit );
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

unsigned int SDHCALCaloHitConverter::getThreshold( const EVENT::RawCalorimeterHit *const pInputCaloHit )
{
	int shift;
	const float amplitude( static_cast<float>( pInputCaloHit->getAmplitude() & m_amplitudeBitRotation ) );

    if( amplitude > 2.5 )
		shift = 0;         // 3rd threshold
    else if( amplitude > 1.5 )
		shift = -1;        // 2nd threshold
	else
		shift = +1;        // 1rst Threshold

	return static_cast<unsigned int>(amplitude) + shift;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALCaloHitConverter::readSettings(const dqm4hep::TiXmlHandle handle)
{
	if( m_isInitialized )
		return dqm4hep::STATUS_CODE_SUCCESS;

	dqm4hep::TiXmlElement *pMappingXmlElement = handle.FirstChild("electronicsMapping").Element();

	if( ! pMappingXmlElement )
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	std::string plugin;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::getAttribute(pMappingXmlElement, "plugin", plugin));

	// query electronics mapping plugin instance and configure
	m_pElectronicsMapping = dqm4hep::DQMPluginManager::instance()->createPluginClass<dqm4hep::DQMElectronicsMapping>(plugin);

	dqm4hep::TiXmlHandle mappingHandle(pMappingXmlElement);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->readSettings(mappingHandle));

	m_amplitudeBitRotation = 3;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(handle,
	                        "AmplitudeBitRotation", m_amplitudeBitRotation));

	m_encodeDifAsicChannel = true;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(handle,
	                 "EncodeDifAsicChannel", m_encodeDifAsicChannel));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(handle,
			"IJKEncoding", m_ijkEncoding, [&] (const dqm4hep::StringVector &vec) {
		return vec.size() == 3;
	}));

	m_cellIDEncoderString = "M:3,S-1:3,I:9,J:9,K-1:6";

	if( m_encodeDifAsicChannel )
	{
		m_cellIDEncoderString = "I:7,J:7,K-1:6,Dif_id:8,Asic_id:8,Chan_id:6";

		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(handle,
				"DifAsicChannelEncoding", m_difAsicChannelEncoding, [&] (const dqm4hep::StringVector &vec) {
			return vec.size() == 3;
		}));
	}

	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(handle,
	                        "CellIDEncoderString", m_cellIDEncoderString));

	m_isInitialized = true;

	return dqm4hep::STATUS_CODE_SUCCESS;
}



}

