  /// \file DataConverters.cc
/*
 *
 * DataConverters.cc source template automatically generated by a class generator
 * Creation date : ven. avr. 8 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqmsdhcal headers
#include "DataConverters.h"

// -- dqm4hep headers
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMElectronicsMapping.h"
#include "dqm4hep/DQMXmlHelper.h"

// -- lcio headers
#include "UTIL/CellIDEncoder.h"

namespace dqm_sdhcal
{

// declare dqm plugin instance
DQM_PLUGIN_DECL(SDHCALCaloHitConverter, "SDHCALCaloHitConverter")

//-------------------------------------------------------------------------------------------------

SDHCALCaloHitConverter::SDHCALCaloHitConverter() :
	m_isInitialized(false)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SDHCALCaloHitConverter::~SDHCALCaloHitConverter()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALCaloHitConverter::convert(const EVENT::LCCollection *const pInputCollection, EVENT::LCCollection *const pOutputCollection)
{
	if( ! m_isInitialized )
		return dqm4hep::STATUS_CODE_NOT_INITIALIZED;

	if( pInputCollection->getTypeName() != EVENT::LCIO::RAWCALORIMETERHIT || pOutputCollection->getTypeName() != EVENT::LCIO::CALORIMETERHIT )
		return dqm4hep::STATUS_CODE_INVALID_PARAMETER;

	UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> cellIDEncoder( m_cellIDEncoderString , pOutputCollection );

	for(unsigned int e=0 ; e<pInputCollection->getNumberOfElements() ; e++)
	{
		EVENT::RawCalorimeterHit *pRawCaloHit = dynamic_cast<EVENT::RawCalorimeterHit *>(pInputCollection->getElementAt(e));

		if( NULL == pRawCaloHit )
			continue;

		int cellID = pRawCaloHit->getCellID0();
		unsigned int threshold = this->getThreshold( pRawCaloHit );

		dqm4hep::DQMElectronicsMapping::Electronics electronics;

		// extract raw data electronics ids
		electronics.m_difId = this->getDifId( cellID );
		electronics.m_asicId = this->getAsicId( cellID );
		electronics.m_channelId = this->getChannelId( cellID );

		// perform conversion to cell ids and absolute position
		dqm4hep::DQMCartesianVector position(0.f, 0.f, 0.f);
		dqm4hep::DQMElectronicsMapping::Cell cell;
		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicsToPosition(electronics, position));
		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicstoCell(electronics, cell));

	    // set the cell id
		cellIDEncoder["I"] = cell.m_iCell;
		cellIDEncoder["J"] = cell.m_jCell;
	    cellIDEncoder["K-1"] = cell.m_layer;
	    cellIDEncoder["M"] = 0;
	    cellIDEncoder["S-1"] = 3;
	    float positionArray [3] = { position.getX() , position.getY() , position.getZ() };

		// create hit and fill infos
		IMPL::CalorimeterHitImpl *pCaloHit = new IMPL::CalorimeterHitImpl();

		pCaloHit->setTime( static_cast<float>( pRawCaloHit->getTimeStamp() ) );
		pCaloHit->setEnergy( static_cast<float>( threshold ) );
		pCaloHit->setPosition( positionArray );
		cellIDEncoder.setCellID( pCaloHit );
		pCaloHit->setRawHit( pRawCaloHit );

		pOutputCollection->addElement( pCaloHit );
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

unsigned int SDHCALCaloHitConverter::getThreshold( const EVENT::RawCalorimeterHit *const pInputCaloHit )
{
	int shift;
	const float amplitude( static_cast<float>( pInputCaloHit->getAmplitude() & 3 ) );

    if( amplitude > 2.5 )
    	shift = 0;         // 3rd threshold
    else if( amplitude > 1.5 )
    	shift = -1;        // 2nd threshold
    else
    	shift = +1;        // 1rst Threshold

    return static_cast<unsigned int>(amplitude) + shift;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALCaloHitConverter::readSettings(const dqm4hep::TiXmlHandle handle)
{
	if( m_isInitialized )
		return dqm4hep::STATUS_CODE_SUCCESS;

	dqm4hep::TiXmlElement *pMappingXmlElement = handle.FirstChild("electronicsMapping").Element();

	if( ! pMappingXmlElement )
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	std::string plugin;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::getAttribute(pMappingXmlElement, "plugin", plugin));

	// query electronics mapping plugin instance and configure
	m_pElectronicsMapping = dqm4hep::DQMPluginManager::instance()->createPluginClass<dqm4hep::DQMElectronicsMapping>(plugin);

	dqm4hep::TiXmlHandle mappingHandle(pMappingXmlElement);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->readSettings(mappingHandle));

	m_cellIDEncoderString = "M:3,S-1:3,I:9,J:9,K-1:6";
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(handle,
			"CellIDEncoderString", m_cellIDEncoderString));

	m_isInitialized = true;

	return dqm4hep::STATUS_CODE_SUCCESS;
}



} 

