  /// \file DQMTriventModule.cc
/*
 *
 * DQMTriventModule.cc source template automatically generated by a class generator
 * Creation date : mar. mars 8 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "DQMTriventModule.h"
#include "Trivent.h"

// -- dqm4hep headers
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMPluginManager.h"

// -- lcio headers
#include "EVENT/LCIO.h"
#include "UTIL/LCTOOLS.h"
#include "Exceptions.h"
#include "EVENT/LCEvent.h"
// #include "EVENT/RawCalorimeterHit.h"
#include "IMPL/CalorimeterHitImpl.h"
#include "IMPL/LCCollectionVec.h"

namespace dqm_sdhcal
{

DQMTriventModule::DQMTriventModule() :
		DQMAnalysisModule(),
		LCTriventListener()
{
	m_pTrivent = new trivent::Trivent();
	m_pTrivent->addListener(this);
}

//-------------------------------------------------------------------------------------------------

DQMTriventModule::~DQMTriventModule() 
{
	delete m_pTrivent;

	// for(std::vector< CaloHitCollectionConverter *>::iterator iter = m_dataConverters.begin(), endIter = m_dataConverters.end() ;
	// 		endIter != iter ; ++iter)
	// 	delete *iter;

	// m_dataConverters.clear();
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode DQMTriventModule::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	dqm4hep::TiXmlElement *pXmlElement = xmlHandle.FirstChild("Trivent").Element();

	if( ! pXmlElement )
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	dqm4hep::TiXmlHandle triventHandle(pXmlElement);

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(triventHandle,
			"RawCollectionNames", m_caloHitCollectionNames, [] (const dqm4hep::StringVector &vec) { return ! vec.empty(); }));

	// RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(triventHandle,
	// 		"RawCollectionNames", m_rawCollectionNames, [] (const dqm4hep::StringVector &vec) { return ! vec.empty(); }));

	// RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(triventHandle,
			// "RecCollectionNames", m_recCollectionNames, [&] (const dqm4hep::StringVector &vec) { return vec.size() == (m_rawCollectionNames.size() + m_caloHitCollectionNames.size() ); }));

	/*------------- Read converter settings ------------*/
	// dqm4hep::TiXmlElement *pConvXmlElement = triventHandle.FirstChild("RawDataConverters").Element();

	// if( ! pConvXmlElement )
	// 	return dqm4hep::STATUS_CODE_NOT_FOUND;

	// dqm4hep::TiXmlHandle convertersHandle(pConvXmlElement);

 //    for (dqm4hep::TiXmlElement *pXmlElement = convertersHandle.FirstChild("converter").Element(); NULL != pXmlElement;
 //        pXmlElement = pXmlElement->NextSiblingElement("converter"))
    // {
		// if( m_dataConverters.size() == ( m_rawCollectionNames.size() + m_caloHitCollectionNames.size() ) )
		// {
		// 	LOG4CXX_WARN( dqm4hep::dqmMainLogger, "Warning additional raw data converter plugin loading will be skipped !" );
		// 	break;
		// }

  //   	std::string plugin;
  //   	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::getAttribute(pXmlElement, "plugin", plugin));

   //  	dqm4hep::StringVector inputCollection;
			// RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(triventHandle,
			// "inputCollection", inputCollection));
			
  //   	CaloHitCollectionConverter *pConverter = dqm4hep::DQMPluginManager::instance()->createPluginClass<CaloHitCollectionConverter>(plugin);

		// if( NULL == pConverter )
		// 	return dqm4hep::STATUS_CODE_NOT_FOUND;

		// dqm4hep::TiXmlHandle converterHandle(pXmlElement);
		// RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, pConverter->readSettings(converterHandle));

		// m_dataConverters.emplace( inputCollection, pConverter );
  //   }

    // if( m_dataConverters.size() != ( m_rawCollectionNames.size() +  m_caloHitCollectionNames.size() ) ) 
    	// return dqm4hep::STATUS_CODE_INVALID_PARAMETER;
    /*---------------------------------------------------*/

	m_triventParameters.m_timeWindow = 2;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(triventHandle,
			"TimeWindow", m_triventParameters.m_timeWindow));

	m_triventParameters.m_minPeakSize = 10;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(triventHandle,
			"MinPeakSize", m_triventParameters.m_minPeakSize));

	m_triventParameters.m_minElements = 10;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(triventHandle,
			"MinElements", m_triventParameters.m_minElements));

	m_triventParameters.m_maxElements = std::numeric_limits<uint32_t>::max();
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(triventHandle,
			"MaxElements", m_triventParameters.m_maxElements));

	dqm4hep::StringVector maskCollectionNames;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(triventHandle,
			"MaskCollectionNames", maskCollectionNames));

	m_triventParameters.m_maskCollectionNames.insert(maskCollectionNames.begin(), maskCollectionNames.end());

	// forward parsing to Trivent
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->userReadSettings(xmlHandle));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode DQMTriventModule::initModule()
{
	m_pTrivent->init(m_triventParameters);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->userInitModule());

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode DQMTriventModule::processEvent(dqm4hep::DQMEvent *const pEvent)
{
	EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

	if(NULL == pLCEvent)
		return dqm4hep::STATUS_CODE_FAILURE;

	LOG4CXX_INFO( dqm4hep::dqmMainLogger, "Processing dqm event no " << pLCEvent->getEventNumber() );

	try
	{
		trivent::Event triventEvent;

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger, "DQMTriventModule : converting event" );
		THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->convertEvent(pLCEvent, triventEvent));

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger, "DQMTriventModule : processing trivent algorithm" );
		m_pTrivent->processEvent(triventEvent);
	}
	catch(dqm4hep::StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught StatusCodeException : " << exception.toString() );
		return exception.getStatusCode();
	}
	catch(EVENT::DataNotAvailableException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
		return dqm4hep::STATUS_CODE_SUCCESS;
	}
	catch(...)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught unknown exception !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode DQMTriventModule::convertEvent(EVENT::LCEvent *pLCEvent, trivent::Event &event)
{
	for (auto &caloHitCollection : m_caloHitCollectionNames)
	{
		try
		{
			// const std::string rawCollectionName(*iter.first);
			// trivent::LCTrivent::addCollection<EVENT::RawCalorimeterHit>(pLCEvent,
					// rawCollectionName, event, &EVENT::RawCalorimeterHit::getTimeStamp);
			
			const std::string caloHitCollectionName(caloHitCollection);
			trivent::LCTrivent::addCollection<EVENT::CalorimeterHit>(pLCEvent,
					caloHitCollectionName, event, &EVENT::CalorimeterHit::getTime);
			
		}
		catch(EVENT::DataNotAvailableException &exception)
		{
			LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
			continue;
		}
	}

	event.setUserEvent( (void *) pLCEvent );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void DQMTriventModule::processReconstructedEvent(EVENT::LCEvent *pLCEvent)
{
	LOG4CXX_DEBUG( dqm4hep::dqmMainLogger, "DQMTriventModule::processReconstructedEvent : event no " << pLCEvent->getEventNumber() );

	// LOG4CXX_DEBUG( dqm4hep::dqmMainLogger, "Performing output data conversion ..." );
	// THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->performOutputDataConversion(pLCEvent));
	// LOG4CXX_DEBUG( dqm4hep::dqmMainLogger, "Performing output data conversion ... OK" );

	LOG4CXX_DEBUG( dqm4hep::dqmMainLogger, "Processing physics event ..." );
	THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->processEvent(pLCEvent));
	LOG4CXX_DEBUG( dqm4hep::dqmMainLogger, "Processing physics event ... OK" );
}

//-------------------------------------------------------------------------------------------------

// dqm4hep::StatusCode DQMTriventModule::performOutputDataConversion(EVENT::LCEvent *pLCEvent)
// {
// 	const unsigned int nCollections(m_rawCollectionNames.size());

// 	for(unsigned int c=0 ; c<nCollections ; c++)
// 	{
// 		const std::string rawCollectionName( m_rawCollectionNames.at(c) );
// 		const std::string recCollectionName( m_recCollectionNames.at(c) );
// 		CaloHitCollectionConverter *pDataConverter( m_dataConverters.at(c) );

// 		try
// 		{
// 			EVENT::LCCollection *pLCCollection = pLCEvent->getCollection( rawCollectionName );
// 			IMPL::LCCollectionVec *pRecCollection = new IMPL::LCCollectionVec(EVENT::LCIO::CALORIMETERHIT);

// 			RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, pDataConverter->convert(pLCCollection, pRecCollection));

// 			pLCEvent->addCollection( pRecCollection , recCollectionName );
// 		}
// 		catch(EVENT::DataNotAvailableException &exception)
// 		{
// 			LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
// 			continue;
// 		}
// 	}

// 	return dqm4hep::STATUS_CODE_SUCCESS;
// }

} 

